{"config":{"lang":["en","pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Selva","text":"<p>Selva is a tool for creating ASGI applications that are easy to build and maintain.</p> <p>It is built on top of asgikit and comes with a dependency injection system built upon Python type annotations. It is compatible with python 3.11+.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Install <code>selva</code> and <code>uvicorn</code>:</p> <pre><code>pip install selva uvicorn[standard]\n</code></pre> <p>Create file <code>application.py</code>:</p> <pre><code>from asgikit.requests import Request\nfrom asgikit.responses import respond_text\nfrom selva.web import get\n\n\n@get\nasync def hello(request: Request):\n    await respond_text(request.response, \"Hello, World\")\n</code></pre> <p>Run application with <code>uvicorn</code>. Selva will automatically load <code>application.py</code>:</p> <pre><code>uvicorn selva.run:app\n</code></pre> <pre><code>INFO:     Started server process [1000]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n</code></pre>"},{"location":"background/","title":"Background services","text":"<p>There are cases where you need to run code in parallel of your application, for example, to listen to a messaging queue.</p> <p>Selva provides the <code>selva.web.background</code> decorator to mark functions as background services that will be started as async tasks and run alongside the main application.</p> <pre><code>from selva.web import background\n\n\n@background\nasync def background_service():\n    ...\n</code></pre> <p>Background service functions can receive services as parameters from the dependency injection system.</p> <p>For example, you can create a function that listens for notification from Redis: </p> <pre><code>from redis.asyncio import Redis\nfrom selva.web import background\nimport structlog\n\nlogger = structlog.get_logger()\n\n\n@background\nasync def listen_channel(redis: Redis):\n    async with redis.pubsub() as pubsub:\n        await pubsub.psubscribe(\"chat\")\n        while True:\n            if message := await pubsub.get_message(\n                ignore_subscribe_messages=True,\n                timeout=None\n            ):\n                logger.info(\"chat\", message=message[\"data\"].decode())\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>Settings in Selva are handled through YAML files. Internally it uses ruamel.yaml, so it supports YAML 1.2.</p> <p>Settings files are located by default in the <code>configuration</code> directory with the base name <code>settings.yaml</code>:</p> <pre><code>project/\n\u251c\u2500\u2500 application/\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 configuration/\n    \u251c\u2500\u2500 settings.yaml\n    \u251c\u2500\u2500 settings_dev.yaml\n    \u2514\u2500\u2500 settings_prod.yaml\n</code></pre>"},{"location":"configuration/#accessing-the-configuration","title":"Accessing the configuration","text":"<p>The configuration values can be accessed by injecting <code>selva.configuration.Settings</code>.</p> <pre><code>from typing import Annotated\nfrom selva.configuration import Settings\nfrom selva.di import Inject, service\n\n\n@service\nclass MyService:\n    settings: Annotated[Settings, Inject]\n</code></pre> <p>The <code>Settings</code> object is a <code>dict</code> like object that can also be accessed using property syntax:</p> <pre><code>from selva.configuration import Settings\n\nsettings = Settings({\"config\": \"value\"})\nassert settings[\"config\"] == \"value\"\nassert settings.config == \"value\"\n</code></pre>"},{"location":"configuration/#typed-settings","title":"Typed settings","text":"<p>Configuration loaded from YAML files are all <code>dict</code>s. However, we can use <code>pydantic</code> and the dependency injection system to provide access to settings in a more typed manner:</p> application.pyconfiguration/settings.yaml <pre><code>from pydantic import BaseModel\nfrom selva.configuration import Settings\nfrom selva.di import service\n\n\nclass MySettings(BaseModel):\n    int_property: int\n    bool_property: bool\n\n\n@service\ndef my_settings(settings: Settings) -&gt; MySettings:\n    return MySettings.model_validate(settings.my_settings)\n</code></pre> <pre><code>my_settings:\n  int_property: 1\n  bool_property: true\n</code></pre>"},{"location":"configuration/#environment-substitution","title":"Environment substitution","text":"<p>The settings files can include references to environment variables that takes the format <code>${ENV_VAR:default_value}</code>. The default value is optional and an error will be raised if neither the environment variable nor the default value are defined.</p> <pre><code>required: ${ENV_VAR}         # required environment variable\noptional: ${OPT_VAR:default} # optional environment variable\n</code></pre>"},{"location":"configuration/#profiles","title":"Profiles","text":"<p>Optional profiles can be activated by setting the environment variable <code>SELVA_PROFILE</code>. The framework will look for a file named <code>settings_${SELVA_PROFILE}.yaml</code> and merge the values with the main <code>settings.yaml</code>. Values from the profile settings take precedence over the values from the main settings.</p> <p>As an example, if we define <code>SELVA_PROFILE=dev</code>, the file <code>settings_dev.yaml</code> will be loaded. If instead we define <code>SELVA_PROFILE=prod</code>, then the file <code>settings_prod.yaml</code> will be loaded.</p> <p>Multiple profiles can be activated by setting <code>SELVA_PROFILE</code> with a comma separated list of profiles, for example <code>SELVA_PROFILE=dev,prod</code>. The framework will iterate over the list and merge the settings found on each one. The precedence is from last to first, so settings from one profile overwrite settings from the previous ones.</p>"},{"location":"configuration/#environment-variables","title":"Environment variables","text":"<p>Settings can also be defined with environment variables whose names start with <code>SELVA__</code>, where subsequent double undercores (<code>__</code>) indicates nesting (variable is a mapping). Also, variable names will be lowercased.</p> <p>For example, consider the following environment variables:</p> <pre><code>SELVA__PROPERTY=1\nSELVA__MAPPING__PROPERTY=2\nSELVA__MAPPING__ANOTHER_PROPERTY=3\n</code></pre> <p>Those variables will be collected as the following:</p> <pre><code>{\n    \"property\": \"1\",\n    \"mapping\": {\n        \"property\": \"2\",\n        \"another_property\": \"3\",\n    },\n}\n</code></pre>"},{"location":"configuration/#dotenv","title":"DotEnv","text":"<p>If running you project using <code>selva.run.app</code>, for example <code>uvicorn selva.run:app</code>, environment variables can be loaded from a <code>.env</code> file. The parsing is done using the python-dotenv library.</p> <p>By default, a <code>.env</code> file in the current working directory will be loaded, but it can be customized with the environment variable <code>SELVA_DOTENV</code> pointing to a <code>.env</code> file.</p>"},{"location":"handlers/","title":"Handlers","text":""},{"location":"handlers/#overview","title":"Overview","text":"<p>Handlers are functions responsible for handling received requests. They are defined using the <code>@get</code>, <code>@post</code>, <code>@put</code>, <code>@patch</code>, <code>@delete</code> and <code>@websocket</code> decorators.</p> <p>Handlers must receive, at least, the request object as the first parameter. It is not needed to annotate the request parameter, but it should be the first parameter.</p> <pre><code>from asgikit.requests import Request, read_json\nfrom asgikit.responses import respond_text, respond_redirect\nfrom selva.web import get, post\nimport structlog\n\nlogger = structlog.get_logger()\n\n\n@get\nasync def index(request: Request):\n    await respond_text(request.response, \"application root\")\n\n\n@post(\"send\")\nasync def handle_data(request: Request):\n    content = await read_json(request)\n    logger.info(\"request body\", content=repr(content))\n    await respond_redirect(request.response, \"/\")\n</code></pre> <p>Note</p> <p>Defining a path on <code>@get @post etc...</code> is optional and defaults to an empty string <code>\"\"</code>.</p> <p>Handler function can be defined with path parameters, which can be bound to the handler with the annotation <code>FromPath</code>:</p> <pre><code>from typing import Annotated\nfrom selva.web import get, FromPath\n\n\n@get(\"/:path_param\")\ndef handler(request, path_param: Annotated[str, FromPath]):\n    ...\n</code></pre> <p>It is also possible to explicitly declare from which parameter the value will be retrieved from:</p> <pre><code>from typing import Annotated\nfrom selva.web import get, FromPath\n\n\n@get(\"/:path_param\")\ndef handler(request, value: Annotated[str, FromPath(\"path_param\")]):\n    ...\n</code></pre> <p>The routing section provides more information about path parameters</p>"},{"location":"handlers/#responses","title":"Responses","text":"<p>Inheriting the <code>asgikit.responses.Response</code> from <code>asgikit</code>, the handler functions do not return a response, instead they write to the response.</p> <pre><code>from asgikit.requests import Request\nfrom asgikit.responses import respond_json\nfrom selva.web import get\n\n\n@get\nasync def handler(request: Request):\n    await respond_json(request.response, {\"data\": \"The response\"})\n</code></pre> <p><code>asgikit</code> provides function to write data to the response:</p> <pre><code>from collections.abc import AsyncIterable\nfrom http import HTTPStatus\n\nfrom asgikit.responses import Response\n\n\nasync def respond_text(response: Response, content: str | bytes): ...\nasync def respond_status(response: Response, status: HTTPStatus): ...\nasync def respond_redirect(response: Response, location: str, permanent: bool = False): ...\nasync def respond_redirect_post_get(response: Response, location: str): ...\nasync def respond_json(response: Response, content): ...\nasync def stream_writer(response: Response): ...\nasync def respond_stream(response: Response, stream: AsyncIterable[bytes | str]): ...\n</code></pre>"},{"location":"handlers/#dependencies","title":"Dependencies","text":"<p>Handler functions can receive services as parameters that will be injected when the handler is called.</p> <pre><code>from typing import Annotated\nfrom selva.di import service, Inject\nfrom selva.web import get\n\n\n@service\nclass MyService:\n    pass\n\n\n@get\ndef my_handler(request, my_service: Annotated[MyService, Inject]):\n    ...\n</code></pre>"},{"location":"handlers/#request-information","title":"Request Information","text":"<p>Handler functions receive an object of type <code>asgikit.requests.Request</code> as the first parameter that provides access to request information (path, method, headers, query string, request body). It also provides the <code>asgikit.responses.Response</code> or <code>asgikit.websockets.WebSocket</code> objects to either respond the request or interact with the client via websocket.</p> <p>Attention</p> <p>For http requests, <code>Request.websocket</code> will be <code>None</code>, and for websocket requests, <code>Request.response</code> will be <code>None</code></p> <pre><code>from http import HTTPMethod, HTTPStatus\nfrom asgikit.requests import Request\nfrom asgikit.responses import respond_json\nfrom selva.web import get, websocket\n\n\n@get\nasync def handler(request: Request):\n    assert request.response is not None\n    assert request.websocket is None\n\n    assert request.method == HTTPMethod.GET\n    assert request.path == \"/\"\n    await respond_json(request.response, {\"status\": HTTPStatus.OK})\n\n@websocket\nasync def ws_handler(request: Request):\n    assert request.response is None\n    assert request.websocket is not None\n\n    ws = request.websocket\n    await ws.accept()\n    while True:\n        data = await ws.receive()\n        await ws.send(data)\n</code></pre>"},{"location":"handlers/#request-body","title":"Request body","text":"<p><code>asgikit</code> provides several functions to retrieve the request body:</p> <pre><code>from asgikit.requests import Body, Request\nfrom python_multipart import multipart\n\n\nasync def read_body(request: Body | Request) -&gt; bytes: ...\nasync def read_text(request: Body | Request, encoding: str = None) -&gt; str: ...\nasync def read_json(request: Body | Request) -&gt; dict | list: ...\nasync def read_form(request: Body | Request) -&gt; dict[str, str | multipart.File]: ...\n</code></pre>"},{"location":"handlers/#websockets","title":"Websockets","text":"<p>For websockets, there are the following functions:</p> <pre><code>from collections.abc import Iterable\n\n\nasync def accept(subprotocol: str = None, headers: Iterable[tuple[str, str | list[str]]] = None): ...\nasync def receive(self) -&gt; str | bytes: ...\nasync def send(self, data: bytes | str): ...\nasync def close(self, code: int = 1000, reason: str = \"\"): ...\n</code></pre>"},{"location":"handlers/#request-parameters","title":"Request Parameters","text":"<p>Handler functions can receive additional parameters, which will be extracted from the request using an implementation of <code>selva.web.FromRequest[T]</code>. If there is no direct implementation of <code>FromRequest[T]</code>, Selva will iterate over the base types of <code>T</code> until an implementation is found or an error will be returned if there is none.</p> <p>You can use the <code>register_from_request</code> decorator to register an <code>FromRequest</code> implementation.</p> <pre><code>from asgikit.requests import Request\nfrom asgikit.responses import respond_text\nfrom selva.web import get\nfrom selva.web.converter.decorator import register_from_request\n\n\nclass Param:\n    def __init__(self, path: str):\n        self.request_path = path\n\n\n@register_from_request(Param)\nclass ParamFromRequest:\n    def from_request(\n        self,\n        request: Request,\n        original_type,\n        parameter_name,\n        metadata,\n        optional,\n    ) -&gt; Param:\n        return Param(request.path)\n\n\n@get\nasync def handler(request: Request, param: Param):\n    await respond_text(request.response, param.request_path)\n</code></pre> <p>If the <code>FromRequest</code> implementation raise an error, the handler is not called. And if the error is a subclass of <code>selva.web.error.HTTPError</code>, for instance <code>HTTPUnauthorizedException</code>, a response will be produced according to the error.</p> <pre><code>from selva.web.exception import HTTPUnauthorizedException\n\n\n@register_from_request(Param)\nclass ParamFromRequest:\n    def from_request(\n        self,\n        request: Request,\n        original_type,\n        parameter_name,\n        metadata,\n        optional,\n    ) -&gt; Param:\n        if \"authorization\" not in request.headers:\n            raise HTTPUnauthorizedException()\n        return Param(context.path)\n</code></pre>"},{"location":"handlers/#annotated-parameters","title":"Annotated parameters","text":"<p>If the parameter is annotated (<code>Annotated[T, U]</code>) the framework will look for an implementation of <code>FromRequest[U]</code>, with <code>T</code> being passed as the <code>original_type</code> parameter and <code>U</code> as the <code>metadata</code> parameter.</p>"},{"location":"handlers/#pydantic","title":"Pydantic","text":"<p>Selva already implements <code>FromRequest[pydantic.BaseModel]</code> by reading the request body and parsing the input into the pydantic model, if the content type is json or form, otherwise raising an <code>HTTPError</code> with status code 415. It is also implemented for <code>list[pydantic.BaseModel]</code>.</p>"},{"location":"logging/","title":"Logging","text":"<p>Selva uses Structlog for logging and provides some facilities on top of it to make its usage a bit closer to other frameworks like Spring Boot.</p> <p>It is integrated with the standard library logging, so libraries that use it are logged through Structlog. It also enables filtering by logger name using the standard library.</p>"},{"location":"logging/#why","title":"Why?","text":"<p>Nowadays, it is very likely that your application is deployed to a cloud and its logs are sent to an aggregator like Graylog, so a structured logging format seems to be the logical choice.</p> <p>For more information on why use structured logging, refer to the Structlog documentation.</p>"},{"location":"logging/#configure-logging","title":"Configure logging","text":"<p>Logging is configured in the Selva configuration:</p> <pre><code>logging:\n  root: WARNING # (1)\n  level: # (2)\n    application: INFO\n    selva: DEBUG\n  format: json # (3) \n  setup: selva.logging.setup # (4)\n</code></pre> <ol> <li>Log level of the root logger.</li> <li>Mapping of logger names to log level.</li> <li>Log format. Possible values are <code>\"json\"</code>, <code>\"logfmt\"</code>, <code>\"keyvalue\"</code> and <code>\"console\"</code>.</li> <li>Setup function to configure logging.</li> </ol> <p>The <code>format</code> config defines which renderer will be used. The possible values map to:</p> value renderer <code>json</code> <code>structlog.processors.JSONRenderer()</code> <code>logfmt</code> <code>structlog.processors.LogfmtRenderer(bool_as_flag=True)</code> <code>keyvalue</code> <code>structlog.processors.KeyValueRenderer()</code> <code>console</code> <code>structlog.dev.ConsoleRenderer()</code> <p>If not defined, <code>format</code> defaults to <code>\"json\"</code> if <code>sys.stderr.isatty() == False</code>, or <code>\"console\"</code> otherwise. This is done to use the <code>ConsoleRenderer</code> during development and the <code>JSONRenderer</code> when deploying to production.</p>"},{"location":"logging/#manual-logger-setup","title":"Manual logger setup","text":"<p>If you need full control of how Structlog is configured, you can provide a logger setup function. You just need to reference it in the configuration file:</p> configuration/settings.yamlapplication/logging.py <pre><code>logging:\n  setup: application.logging.setup\n</code></pre> <pre><code>import structlog\nfrom selva.configuration import Settings\n\n\ndef setup(settings: Settings):\n    structlog.configure(...)\n</code></pre> <p>The setup function receives a parameter of type <code>selva.configuration.Settings</code>, so you can have access to the whole settings.</p>"},{"location":"routing/","title":"Routing","text":"<p>Routing is defined by the decorators in the handler functions.</p>"},{"location":"routing/#path-parameters","title":"Path parameters","text":"<p>Parameters can be defined in the handler's path using the syntax <code>:parameter_name</code>, where <code>parameter_name</code> must be the name of the argument on the handler's signature.</p> <pre><code>from typing import Annotated\nfrom asgikit.requests import Request\nfrom asgikit.responses import respond_text\nfrom selva.web import get, FromPath\n\n\n@get(\"hello/:name\")\nasync def handler(request: Request, name: Annotated[str, FromPath]):\n    await respond_text(request.response, f\"Hello, {name}!\")\n</code></pre> <p>Here was used <code>Annotated</code> and <code>FromPath</code> to indicated that the handler argument is to be bound to the parameter from the request path. More on that will be explained in the following sections.</p>"},{"location":"routing/#path-matching","title":"Path matching","text":"<p>The default behavior is for a path parameter to match a single path segment. If you want to match the whole path, or a subpath of the request path, use the syntax <code>*parameter_name</code>.</p> <pre><code>from typing import Annotated\nfrom asgikit.requests import Request\nfrom asgikit.responses import respond_text\nfrom selva.web import get, FromPath\n\n\n@get(\"hello/*path\")\nasync def handler(request: Request, path: Annotated[str, FromPath]):\n    name = \" \".join(path.split(\"/\"))\n    await respond_text(request.response, f\"Hello, {name}!\")\n</code></pre> <p>For a request like <code>GET hello/Python/World</code>, the handler will output <code>Hello, Python World!</code>.</p> <p>You can mix both types of parameters with no problem:</p> <ul> <li><code>*path</code></li> <li><code>*path/literal_segment</code></li> <li><code>:normal_param/*path</code></li> <li><code>:normal_param/*path/:other_path</code></li> </ul>"},{"location":"routing/#parameter-conversion","title":"Parameter conversion","text":"<p>Parameter conversion is done through the type annotation on the parameter. The framework will try to find a converter suitable for the parameter type and then convert the value before calling the handler.</p> <pre><code>from typing import Annotated\nfrom asgikit.requests import Request\nfrom asgikit.responses import respond_json\nfrom selva.web import get, FromPath\n\n\n@get(\"repeat/:amount\")\nasync def handler(request: Request, amount: Annotated[int, FromPath]):\n    await respond_json(request.response, {f\"repeat {i}\": i for i in range(amount)})\n</code></pre> <p>The framework will look for a service implementing <code>selva.web.converter.from_request.FromRequest[FromPath]</code> in order to get the data from the request, then this service will look for a converter, a service implementing <code>selva.web.converter.Converter[str, int]</code> to convert the data to the requested type.</p> <p>Selva already provide converters for the types <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code> and <code>pathlib.PurePath</code>.</p>"},{"location":"routing/#custom-parameter-conversion","title":"Custom parameter conversion","text":"<p>Conversion can be customized by providing an implementing of <code>selva.web.converter.Converter</code>. You normally use the shortcut decorator <code>selva.web.converter.decorator.register_converter.</code></p> <pre><code>from dataclasses import dataclass\nfrom typing import Annotated\n\nfrom asgikit.requests import Request\nfrom asgikit.responses import respond_text\nfrom selva.web import get, FromPath\nfrom selva.web.converter.decorator import register_converter\n\n\n@dataclass\nclass MyModel:\n    name: str\n\n\n@register_converter(str, MyModel)\nclass MyModelParamConverter:\n    def convert(self, value: str) -&gt; MyModel:\n        return MyModel(value)\n\n\n@get(\"/:model\")\nasync def handler(request: Request, model: Annotated[MyModel, FromPath]):\n    await respond_text(request.response, str(model))\n</code></pre> <p>If the <code>Converter</code> implementation raise an error, the handler is not called. And if the error is a subclass of <code>selva.web.error.HTTPError</code>, for instance <code>HTTPUnauthorizedException</code>, a response will be produced according to the error.</p>"},{"location":"services/","title":"Services","text":"<p>Services are types registered with the dependency injection container that can be injected in other services and handlers. They are defined with the decorator <code>@service</code>.</p> <pre><code>from typing import Annotated\nfrom selva.di import Inject, service\n\n\n@service\nclass MyService:\n    pass\n\n\n@service\nclass MyOtherService:\n    dependency: Annotated[MyService, Inject]\n\n\nclass SomeClass:\n    pass\n\n\nclass OtherClass:\n    def __init__(self, dependency: SomeClass):\n        self.dependency = dependency\n\n\n@service\nasync def factory() -&gt; SomeClass:\n    return SomeClass()\n\n\n@service\nasync def other_factory(dependency: SomeClass) -&gt; OtherClass:\n    return OtherClass(dependency)\n</code></pre>"},{"location":"services/#service-classes","title":"Service classes","text":"<p>Services defined as classes have dependencies as class annotations.</p> <pre><code>from typing import Annotated\nfrom selva.di import Inject, service\n\n\n@service\nclass MyService:\n    pass\n\n\n@service\nclass OtherService:\n    property: Annotated[MyService, Inject]\n</code></pre> <p>When the service type is requested in the dependency injection container, the class will be inspected for the annotated dependencies that will be created and then injected into the requested service.</p> <p>Annotations without <code>Inject</code> will be ignored.</p>"},{"location":"services/#initializers-and-finalizers","title":"Initializers and finalizers","text":"<p>Optionally, service classes can define two methods: <code>initialize()</code>, that will be called after service creation and dependency injection; and <code>finalize()</code>, that will be called on application shutdown.</p> <pre><code>from selva.di import service\n\n\n@service\nclass MyService:\n    async def initialize(self):\n        \"\"\"perform initialization logic\"\"\"\n\n    async def finalize(self):\n        \"\"\"perform finalization logic\"\"\"\n</code></pre> <p>The <code>initialize()</code> and <code>finalize()</code> methods do not need to be async.</p>"},{"location":"services/#services-providing-an-interface","title":"Services providing an interface","text":"<p>You can have services that provide an interface instead of their own type, so we request the interface as dependency instead of the concrete type.</p> <pre><code>from typing import Annotated\n\nfrom selva.di import Inject, service\n\n\nclass Interface:\n    def some_method(self): pass\n\n\n@service(provides=Interface)\nclass MyService:\n    def some_method(self): pass\n\n\n@service\nclass OtherService:\n    dependency: Annotated[Interface, Inject]\n</code></pre> <p>When <code>OtherService</code> is created, the dependency injection container look for a service of type <code>Interface</code> and will produce an instance of the <code>MyService</code> class.</p>"},{"location":"services/#named-services","title":"Named services","text":"<p>Services can be registered with a name, so you can have more than one service of the same type, given they have distinct names. Without a name, a service is registered as the default for that type.</p> <pre><code>from typing import Annotated\n\nfrom selva.di import Inject, service\n\n\nclass Interface: pass\n\n\n@service(name=\"A\", provides=Interface)\nclass ServiceA: pass\n\n\n@service(name=\"B\", provides=Interface)\nclass ServiceB: pass\n\n\n@service\nclass OtherService:\n    dependency_a: Annotated[Interface, Inject(name=\"A\")]\n    dependency_b: Annotated[Interface, Inject(name=\"B\")]\n</code></pre>"},{"location":"services/#optional-dependencies","title":"Optional dependencies","text":"<p>If a requested dependency is not registered, an error is raised, unless there is a default value declared, in the case the property will have that value when the service is created.</p> <pre><code>from typing import Annotated\n\nfrom selva.di import Inject, service\n\n\n@service\nclass SomeService:\n    pass\n\n\n@service\nclass MyService:\n    dependency: Annotated[SomeService, Inject] = None\n\n    def some_method(self):\n        if self.dependency:\n            ...\n</code></pre>"},{"location":"services/#services-as-factory-functions","title":"Services as factory functions","text":"<p>In order to register a type that we do not own, for example, a type from an external library, we can use a factory function:</p> <pre><code>from selva.di import service\nfrom some_library import SomeClass\n\n\n@service\nasync def some_class_factory() -&gt; SomeClass:\n    return SomeClass()\n</code></pre> <p>The return type annotation is required in factory functions, as that will be the service provided by function. If the return type annotation is not provided, an error is raised.</p> <p>The value of the parameter <code>provides</code> in <code>@service</code> is ignored when decorating a factory function, and a warning will be raised.</p> <p>Factory function parameters do not need the <code>Inject</code> annotation, unless they need to specify a named dependency:</p> <pre><code>from typing import Annotated\n\nfrom selva.di import Inject, service\nfrom some_library import SomeClass\n\n\n@service\nasync def some_class_factory(\n    dependency: MyService,\n    other: Annotated[OtherService, Inject(name=\"service_name\")]\n) -&gt; SomeClass:\n    return SomeClass()\n</code></pre>"},{"location":"services/#initialization-and-finalization","title":"Initialization and finalization","text":"<p>To perform initialization on factory functions, you just execute the logic before returning the service.</p> <pre><code>from selva.di import service\n\n\nclass SomeClass:\n    pass\n\n\n@service\nasync def factory() -&gt; SomeClass:\n    some_service = SomeClass()\n    # perform initialization login\n    return some_service\n</code></pre> <p>To perform finalization, you use the <code>yield</code> instead of <code>return</code> and execute the finalization logic afterward.</p> <pre><code>from selva.di import service\n\n\nclass SomeClass:\n    pass\n\n\n@service\nasync def factory() -&gt; SomeClass:\n    some_service = SomeClass()\n    # perform initialization logic\n    yield some_service\n    # perform finalization logic\n</code></pre>"},{"location":"services/#named-services_1","title":"Named services","text":"<p>Named services work the same as in service classes.</p> <pre><code>from typing import Annotated\n\nfrom selva.di import Inject, service\n\nfrom some_library import SomeClass\n\n\n@service(name=\"service_name\")\ndef factory() -&gt; SomeClass:\n    return SomeClass\n\n\n@service\nclass MyService:\n    dependency: Annotated[SomeClass, Inject(name=\"service_name\")]\n</code></pre>"},{"location":"services/#optional-dependencies_1","title":"Optional dependencies","text":"<p>Optional dependencies work the same as in service classes, in that you specify a default value for the argument.</p> <pre><code>from typing import Annotated\n\nfrom selva.di import Inject, service\nfrom some_library import SomeClass\n\n\n@service\nasync def some_class_factory(\n    dependency: MyService,\n    other: Annotated[OtherService, Inject(name=\"service_name\")] = None\n) -&gt; SomeClass:\n    if other:\n        ...\n\n    return SomeClass()\n</code></pre>"},{"location":"startup/","title":"Startup hooks","text":"<p>Selva provides decorators to mark functions as hooks that will be called when the application starts. The functions will be called in the order they are discovered and if any of them raise en error, the application will not start.</p> <pre><code>from selva.web import startup\n\n\n@startup\ndef my_startup_hook():\n    ...\n</code></pre> <p>Startup functions can receive services as parameters through the dependency injection system.</p> <pre><code>from selva.di import service\nfrom selva.web import startup\n\n\n@service\nclass OIDCService:\n    async def oidc_discovey(self):\n        ...\n\n\n@startup\nasync def my_startup_hook(oidc_service: OIDCService):\n    await oidc_service.oidc_discovey()\n</code></pre> <p>You can use the <code>Inject</code> annotation if you need a named service.</p> <pre><code>from typing import Annotated\n\nfrom selva.di import Inject, service\nfrom selva.web import startup\n\n\n@service(name=\"provider\")\nclass OIDCService:\n    async def oidc_discovey(self):\n        ...\n\n\n@startup\nasync def my_startup_hook(\n    oidc_service: Annotated[OIDCService, Inject(name=\"provider\")]\n):\n    await oidc_service.oidc_discovey()\n</code></pre>"},{"location":"structure/","title":"Project Structure","text":"<p>In a Selva project, you need to define at least the <code>application</code>.</p> <p>It can be a Python module or package and represents the main code of the project. Any handlers and services defined under it will be discovered and registered.</p> <p>If your project is small, you can just define the <code>aplication.py</code> module, but you can have any structure you need inside the <code>application</code> package.</p> <p>For example:</p> <pre><code># minimal\nproject/\n\u2514\u2500\u2500 application.py\n\n# with modules\nproject/\n\u2514\u2500\u2500 application/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 handler.py\n    \u251c\u2500\u2500 model.py\n    \u251c\u2500\u2500 repository.py\n    \u2514\u2500\u2500 service.py\n\n# complex structure\nproject/\n\u2514\u2500\u2500 application/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 handler/\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 public/\n    \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2502   \u251c\u2500\u2500 about.py\n    \u2502   \u2502   \u251c\u2500\u2500 home.py\n    \u2502   \u2502   \u2514\u2500\u2500 product.py\n    \u2502   \u2514\u2500\u2500 private/\n    \u2502       \u251c\u2500\u2500 __init__.py\n    \u2502       \u251c\u2500\u2500 category.py\n    \u2502       \u251c\u2500\u2500 customer.py\n    \u2502       \u2514\u2500\u2500 product.py\n    \u251c\u2500\u2500 model/\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 category.py\n    \u2502   \u251c\u2500\u2500 customer.py\n    \u2502   \u2514\u2500\u2500 product.py\n    \u251c\u2500\u2500 repository/\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 category.py\n    \u2502   \u251c\u2500\u2500 customer.py\n    \u2502   \u2514\u2500\u2500 product.py\n    \u2514\u2500\u2500 service/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 category.py\n        \u251c\u2500\u2500 customer.py\n        \u251c\u2500\u2500 email.py\n        \u2514\u2500\u2500 product.py\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":"<p>Let's dig a little deeper and learn the basic concepts of Selva.</p> <p>We will create a greeting api that logs the greet requests.</p>"},{"location":"tutorial/#installing-selva","title":"Installing Selva","text":"<p>Before going any further, we need to install Selva and Uvicorn.</p> <pre><code>pip install selva uvicorn[standard]\n</code></pre>"},{"location":"tutorial/#structure-of-the-application","title":"Structure of the application","text":"<p>A selva application can be structured like the following:</p> <pre><code># mininal\nproject/\n\u251c\u2500\u2500 application.py\n\u251c\u2500\u2500 configuration/\n\u2502   \u2514\u2500\u2500 settings.yaml\n\u2514\u2500\u2500 resources/\n\n# with modules\nproject/\n\u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 handler.py\n\u2502   \u251c\u2500\u2500 repository.py\n\u2502   \u2514\u2500\u2500 service.py\n\u251c\u2500\u2500 configuration/\n\u2502   \u2514\u2500\u2500 settings.yaml\n\u2514\u2500\u2500 resources/\n</code></pre> <p>And... that's it! A module or package named <code>application</code> will automatically be imported and scanned for handlers and services.</p> <p>You can structure the <code>application</code> package however suits you.</p>"},{"location":"tutorial/#running-the-application","title":"Running the application","text":"<p>We will use <code>uvicorn</code> to run the application and automatically reload when we make changes to the code:</p> <pre><code>$ uvicorn selva.run:app --reload\nINFO:     Will watch for changes in these directories: ['/home/user/projects/selva-tutorial']\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [1001] using WatchFiles\nINFO:     Started server process [1000]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n</code></pre>"},{"location":"tutorial/#handler-functions","title":"Handler functions","text":"<p>Handler functions will respond to HTTP or WebSocket requests. They can receive services through dependency injection.</p> application/handler.py <pre><code>from typing import Annotated\nfrom asgikit.requests import Request\nfrom asgikit.responses import respond_json\nfrom selva.web import get, FromPath\n\n@get(\"hello/:name\") # (1)\nasync def hello(request: Request, name: Annotated[str, FromPath]):\n    await respond_json(request.response, {\"greeting\": f\"Hello, {name}!\"})\n</code></pre> <ol> <li> <p><code>@get(\"hello/:name\")</code> defines the function as a handler on the given path.     If no path is given, the root path (\"/\") will be used.</p> <p><code>:name</code> defines a path parameter that will be bound to the <code>name</code> parameter on the handler, indicated by <code>Annotated[str, FromPath]</code></p> </li> </ol> <p>And now we test if our handler is working:</p> <pre><code>$ curl localhost:8000/hello/World\n{\"greeting\": \"Hello, World!\"}\n</code></pre> <p>Right now our handler just get a name from the path and respond with JSON data to the client.</p>"},{"location":"tutorial/#creating-the-greeter-service","title":"Creating the Greeter service","text":"<p>Our service will have a method that receives a name and returns a greeting. It will be injected into the handler we created previously.</p> application/service.pyapplication/handler.py <pre><code>from selva.di import service\n\n\n@service # (1)\nclass Greeter:\n    def greet(self, name: str) -&gt; str:\n        return f\"Hello, {name}!\"\n</code></pre> <ol> <li><code>@service</code> registers the class in the dependency injection system so it     can be injected in other classes or handler functions</li> </ol> <pre><code>from typing import Annotated\nfrom asgikit.requests import Request\nfrom asgikit.responses import respond_json\nfrom selva.di import Inject\nfrom selva.web import get\nfrom .service import Greeter\n\n\n@get(\"/hello/:name\")\nasync def hello(\n    request: Request,\n    name: Annotated[str, FromPath],\n    gretter: Annotated[Gretter, Inject], # (1)\n):\n    greeting = greeter.greet(name)\n    await respond_json(request.response, {\"greeting\": greeting})\n</code></pre> <ol> <li>Inject the <code>Greeter</code> service</li> </ol>"},{"location":"tutorial/#adding-a-database","title":"Adding a database","text":"<p>Our greeting application is working fine, but we might want to register the greeting requests in a persistent database, for auditing purposes.</p> <p>To do this we need to create the database service and inject it into the <code>Greeter</code> service. For this we can use the Databases library with SQLite support:</p> <pre><code>pip install databases[aiosqlite]\n</code></pre> <p><code>Databases</code> provides a class called <code>Database</code>. However, we can not decorate it with <code>@service</code>, so in this case we need to create a factory function for it:</p> application/repository.pyapplication/handler.py <pre><code>from datetime import datetime\nfrom typing import Annotated\nfrom databases import Database\nfrom selva.di import service, Inject\n\n@service # (1)\nasync def database_factory() -&gt; Database:\n    database = Database(\"sqlite:///database.sqlite3\")\n    await database.connect()\n\n    yield database\n\n    await database.disconnect()\n\n\n@service\nclass GreetingRepository:\n    database: Annotated[Database, Inject] # (2)\n\n    async def initialize(self): # (3)\n        query = \"\"\"\n            create table if not exists greeting_log(\n                greeting text not null,\n                datetime text not null\n            );\n        \"\"\"\n        await database.execute(query)\n\n    async def finalize(self): # (4)\n        query = \"drop table if exists greeting_log;\"\n        await database.execute(query)\n\n    async def save_greeting(self, greeting: str, date: datetime):\n        query = \"\"\"\n            insert into greeting_log (greeting, datetime)\n            values (:greeting, datetime(:datetime))\n        \"\"\"\n        params = {\"greeting\": greeting, \"datetime\": date}\n        await self.database.execute(query, params)\n</code></pre> <ol> <li> <p>A function decorated with <code>@service</code> is used to create a service when     you need to provide types you do not own</p> </li> <li> <p>Inject the <code>Database</code> service in the <code>GreetingRepository</code></p> </li> <li> <p>A method called <code>initialize</code> will be called after the service is     constructed in order to run any initialization logic</p> </li> <li> <p>A method called <code>finalize</code> will be called before the service is     destroyed in order to run any cleanup logic</p> </li> </ol> <pre><code>from typing import Annotated\nfrom datetime import datetime\nfrom asgikit.requests import Request\nfrom asgikit.responses import respond_json\nfrom selva.di import Inject\nfrom selva.web import get, FromPath\nfrom .repository import GreetingRepository\nfrom .service import Greeter\n\n\n@get(\"hello/:name\")\nasync def hello_name(\n    request: Request,\n    name: Annotated[str, FromPath],\n    greeter: Annotated[Greeter, Inject],\n    repository: Annotated[GreetingRepository, Inject],\n):\n    greeting = greeter.greet(name)\n    await repository.save_greeting(greeting, datetime.now())\n    await respond_json(request.response, {\"greeting\": greeting})\n</code></pre>"},{"location":"tutorial/#execute-actions-after-response","title":"Execute actions after response","text":"<p>The greetings are being saved to the database, but now we have a problem: the user has to wait until the greeting is saved before receiving it.</p> <p>To solve this problem and improve the user experience, we can save the greeting after the request is completed:</p> application/handler.py <pre><code>from datetime import datetime\nfrom typing import Annotated\nfrom asgikit.requests import Request\nfrom asgikit.responses improt respond_json\nfrom selva.di import Inject\nfrom selva.web import get, FromPath\nfrom .repository import GreetingRepository\nfrom .service import Greeter\n\n\n@get(\"hello/:name\")\nasync def hello_name(\n    request: Request,\n    name: Annotated[str, FromPath],\n    greeter: Annotated[Greeter, Inject],\n    repository: Annotated[GreetingRepository, Inject],\n):\n    greeting = greeter.greet(name)\n    await respond_json(request.response, {\"greeting\": greeting})  # (1)\n\n    await repository.save_greeting(greeting, datetime.now())  # (2)\n</code></pre> <ol> <li> <p>The call to <code>respond_json</code> completes the response</p> </li> <li> <p>The greeting is saved after the response is completed</p> </li> </ol>"},{"location":"tutorial/#retrieving-the-greeting-logs","title":"Retrieving the greeting logs","text":"<p>To see the greetings saved to the database, we just need to add a handler to get the logs and return them:</p> application/repository.pyapplication/handler.py <pre><code>@service\nclass GreetingRepository:\n    # ...\n    async def get_greetings(self) -&gt; list[tuple[str, str]]:\n        query = \"\"\"\n            select l.greeting, datetime(l.datetime) from greeting_log l\n            order by rowid desc\n        \"\"\"\n        result = await self.database.fetch_all(query)\n        return [{\"greeting\": r.greeting, \"datetime\": r.datetime} for r in result]\n</code></pre> <pre><code># ...\n@get(\"/logs\")\nasync def greeting_logs(\n    request: Request,\n    repository: Annotated[GreetingRepository, Inject],\n):\n    greetings = await repository.get_greetings()\n    await respond_json(request.response, greetings)\n</code></pre> <p>Now let us try requesting some greetings and retrieving the logs:</p> <pre><code>$ curl localhost:8000/hello/Python\n{\"greeting\": \"Hello, Python!\"}\n\n$ curl localhost:8000/hello/World\n{\"greeting\": \"Hello, World!\"}\n\n$ curl -s localhost:8000/logs | python -m json.tool\n[\n    {\n        \"greeting\": \"Hello, World!\",\n        \"datetime\": \"2025-01-01 12:00:10\"\n    },\n    {\n        \"greeting\": \"Hello, Python!\",\n        \"datetime\": \"2025-01-01 12:00:20\"\n    },\n]\n</code></pre>"},{"location":"tutorial/#receiving-post-data","title":"Receiving post data","text":"<p>We can also send the name in the body of the request, instead of the url, and use Pydantic to parse the request body:</p> application/models.pyapplication/handler.py <pre><code>from pydantic import BaseModel\n\n\nclass GreetingRequest(BaseModel):\n    name: str\n</code></pre> <pre><code># ...\nfrom selva.web import FromBody\nfrom .model import GreetingRequest\n\n# ...\n\n@post(\"hello\")\nasync def hello_post(\n    request: Request,\n    greeting_request: Annotated[GreetingRequest, FromBody],\n    greeter: Annotated[Greeter, Inject],\n    repository: Annotated[GreetingRepository, Inject],\n):\n    name = greeting_request.name\n    greeting = greeter.greet(name)\n    await respond_json(request.response, {\"greeting\": greeting})\n    await repository.save_greeting(greeting, datetime.now())\n</code></pre> <p>And to test it:</p> <pre><code>$ curl -H 'Content-Type: application/json' -d '{\"name\": \"World\"}' localhost:8000/hello\n{\"greeting\": \"Hello, World!\"}\n</code></pre>"},{"location":"extensions/overview/","title":"Extensions","text":"<p>Extensions are python packages that provide additional functionality or integrate external libraries into the framework.</p> <p>Current builtin extensions are:</p> <ul> <li>Databases<ul> <li>SQLAlchemy</li> <li>Redis</li> <li>Memcached</li> </ul> </li> <li>Template engines<ul> <li>Jinja</li> <li>Mako</li> </ul> </li> </ul>"},{"location":"extensions/overview/#activating-extensions","title":"Activating extensions","text":"<p>Extensions need to be activated in <code>settings.yaml</code>, in the <code>extensions</code> property:</p> <pre><code>extensions:\n- selva.ext.data.sqlalchemy\n- selva.ext.templates.jinja\n</code></pre>"},{"location":"extensions/overview/#creating-extensions","title":"Creating extensions","text":"<p>An extension is a python package or module that contains a function named <code>init_extension</code> with arguments <code>selva.di.Container</code> and <code>selva.configuration.Settings</code>. It is called during the startup phase of the application and may also be a coroutine.</p> <pre><code>from selva.configuration import Settings\nfrom selva.di import Container\n\nasync def init_extension(container: Container, settings: Settings):\n    pass\n\n# # init_extension can also be sync\n# def init_extension(container: Container, settings: Settings): ...\n</code></pre> <p>The function can then access values in the settings object, register new services, retrieve the router service to register new routes, etc.</p>"},{"location":"extensions/data/memcached/","title":"Memcached","text":"<p>This extension provides support for connecting to Memcached servers. It registers the <code>aiomcache.Client</code> service.</p>"},{"location":"extensions/data/memcached/#usage","title":"Usage","text":"<p>First install the <code>memcached</code> extra:</p> <pre><code>pip install selva[memcached]\n</code></pre> <p>Define the configuration properties:</p> configuration/settings.yaml <pre><code>extensions:\n  - selva.ext.data.memcached # (1)\n\ndata:\n  memcached:\n    default: # (2)\n      address: \"localhost:11211\"\n    other: # (3)\n      address: \"localhost:11212\"\n</code></pre> <ol> <li>Activate the extension</li> <li>\"default\" connection will be registered without a name</li> <li>Connection registered with name \"other\"</li> </ol> <p>Inject the <code>aiomcache.Client</code> service:</p> <pre><code>from typing import Annotated\nfrom aiomcache import Client as Memcached\nfrom selva.di import service, Inject\n\n\n@service\nclass MyService:\n    # default service\n    memcached: Annotated[Memcached, Inject]\n\n    # named service\n    other_memcached: Annotated[Memcached, Inject(name=\"other\")]\n</code></pre>"},{"location":"extensions/data/memcached/#using-environment-variables","title":"Using environment variables","text":"configuration/settings.yaml <pre><code>data:\n  memcached:\n    default:\n      address: \"${MEMCACHED_ADDR}\" # (1)\n</code></pre> <ol> <li>Can be define with just the environment variable <code>SELVA__DATA__MEMCACHED__DEFAULT__ADDRESS</code></li> </ol>"},{"location":"extensions/data/memcached/#example","title":"Example","text":"application/handler.pyconfiguration/settings.yaml <pre><code>from typing import Annotated\n\nfrom aiomcache import Client as Memcached\n\nfrom asgikit.responses import respond_json\n\nfrom selva.di import Inject\nfrom selva.web import get\n\n@get\nasync def index(request, memcached: Annotated[Memcached, Inject]):\n    if not await memcached.get(b\"number\"):\n        await memcached.set(b\"number\", b\"0\")\n    number = await memcached.incr(\"number\")\n    await respond_json(request.response, {\"number\": number})\n</code></pre> <pre><code>data:\n  memcached:\n    default:\n      address: \"localhost:11211\"\n</code></pre>"},{"location":"extensions/data/memcached/#configuration-options","title":"Configuration options","text":"<p>Selva offers several options to configure Memcached. If you need more control over the Memcached service, you can create your own <code>aiomcache.Client</code> service.</p> <p>The available options are shown below:</p> <pre><code>data:\n  memcached:\n    default:\n      address: \"\"\n      options:\n        pool_size: 10\n        pool_minsize: 1\n        get_flat_handler: \"package.module.function\" # (1)\n        set_flat_handler: \"package.module.function\" # (2)\n        conn_args: \"package.module:variable\" # (3)\n</code></pre> <ol> <li>dotted path to a python function</li> <li>dotted path to a python function</li> <li>dotted path to a python variable</li> </ol>"},{"location":"extensions/data/redis/","title":"Redis","text":"<p>This extension provides support for connecting to Redis servers. It registers the <code>redis.asyncio.Redis</code> service.</p>"},{"location":"extensions/data/redis/#usage","title":"Usage","text":"<p>First install the <code>redis</code> extra:</p> <pre><code>pip install selva[redis]\n</code></pre> <p>Define the configuration properties:</p> configuration/settings.yaml <pre><code>extensions:\n  - selva.ext.data.redis # (1)\n\ndata:\n  redis:\n    default: # (2)\n      url: redis://localhost:6379/0\n    other: # (3)\n      url: redis://localhost:6379/1\n</code></pre> <ol> <li>Activate the extension</li> <li>\"default\" connection will be registered without a name</li> <li>Connection registered with name \"other\"</li> </ol> <p>Inject the <code>Redis</code> service:</p> <pre><code>from typing import Annotated\nfrom redis.asyncio import Redis\nfrom selva.di import service, Inject\n\n\n@service\nclass MyService:\n    # default service\n    redis: Annotated[Redis, Inject]\n\n    # named service\n    other_redis: Annotated[Redis, Inject(name=\"other\")]\n</code></pre> <p>Redis connections can also be defined with username and password separated from the url, or even with individual components:</p> configuration/settings.yaml <pre><code>data:\n  redis:\n    url_username_password: # (1)\n      url: redis://localhost:6379/0\n      username: user\n      password: pass\n\n    individual_components: # (2)\n      host: localhost\n      port: 6379\n      db: 0\n      username: user\n      password: pass\n</code></pre> <ol> <li>Username and password separated from the redis url</li> <li>Each component defined individually</li> </ol>"},{"location":"extensions/data/redis/#using-environment-variables","title":"Using environment variables","text":"configuration/settings.yaml <pre><code>data:\n  redis:\n    default:\n      url: \"${REDIS_URL}\" # (1)\n\n    other: # (2)\n      url: \"${REDIS_URL}\"\n      username: \"${REDIS_USERNAME}\"\n      password: \"${REDIS_PASSWORD}\"\n\n    another: # (3)\n      host: \"${REDIS_HOST}\"\n      port: ${REDIS_PORT}\n      db: \"${REDIS_DB}\"\n      username: \"${REDIS_USERNAME}\"\n      password: \"${REDIS_PASSWORD}\"\n</code></pre> <ol> <li>Can be define with just the environment variable <code>SELVA__DATA__REDIS__DEFAULT__URL</code></li> <li>Can be defined with just the environment variables:<ul> <li><code>SELVA__DATA__REDIS__OTHER__URL</code></li> <li><code>SELVA__DATA__REDIS__OTHER__USERNAME</code></li> <li><code>SELVA__DATA__REDIS__OTHER__PASSWORD</code></li> </ul> </li> <li>Can be defined with just the environment variables:<ul> <li><code>SELVA__DATA__REDIS__ANOTHER__HOST</code></li> <li><code>SELVA__DATA__REDIS__ANOTHER__PORT</code></li> <li><code>SELVA__DATA__REDIS__ANOTHER__DB</code></li> <li><code>SELVA__DATA__REDIS__ANOTHER__USERNAME</code></li> <li><code>SELVA__DATA__REDIS__ANOTHER__PASSWORD</code></li> </ul> </li> </ol>"},{"location":"extensions/data/redis/#example","title":"Example","text":"application/handler.pyconfiguration/settings.yaml <pre><code>from typing import Annotated\n\nfrom redis.asyncio import Redis\n\nfrom asgikit.responses import respond_json\n\nfrom selva.di import Inject\nfrom selva.web import get\n\n@get\nasync def index(request, redis: Annotated[Redis, Inject]):\n    number = await redis.incr(\"number\")\n    await respond_json(request.response, {\"number\": number})\n</code></pre> <pre><code>data:\n  redis:\n    default:\n      url: \"redis://localhost:6379/0\"\n</code></pre>"},{"location":"extensions/data/redis/#configuration-options","title":"Configuration options","text":"<p>Selva offers several options to configure Redis. If you need more control over the Redis service, you can create your own <code>redis.asyncio.Redis</code> service.</p> <p>The available options are shown below:</p> <pre><code>data:\n  redis:\n    default:\n      url: \"\"\n      host: \"\"\n      port: 6379\n      db: 0\n      username: \"\"\n      password: \"\"\n      options: # (1)\n        socket_timeout: 1.0\n        socket_connect_timeout: 1.0\n        socket_keepalive: false\n        socket_keepalive_options:\n          TCP_KEEPIDLE: 100,\n          TCP_KEEPCNT: 100,\n          TCP_KEEPINTVL: 100,\n        unix_socket_path: \"\"\n        encoding: \"\"\n        encoding_errors: \"strict\" # or \"ignore\", \"replace\"\n        decode_responses: false\n        retry_on_timeout: false\n        retry_on_error: []\n        ssl: false\n        ssl_keyfile: \"\"\n        ssl_certfile: \"\"\n        ssl_cert_reqs: \"\"\n        ssl_ca_certs: \"\"\n        ssl_ca_data: \"\"\n        ssl_check_hostname: false\n        max_connections: 1\n        single_connection_client: false \n        health_check_interval: 1\n        client_name: \"\"\n        lib_name: \"\"\n        lib_version: \"\"\n        auto_close_connection_pool: false\n        protocol: 3\n        retry:\n          retries: 1\n          supported_errors: # (2)\n            - package.module.Class\n          backoff: # (3)\n            no_backoff:\n            constant:\n              backoff: 1\n            exponential:\n              cap: 1\n              base: 1\n            full_jitter:\n              cap: 1\n              base: 1\n            equal_jitter:\n              cap: 1\n              base: 1\n            decorrelated_jitter:\n              cap: 1\n              base: 1\n</code></pre> <ol> <li><code>options</code> values are described in <code>redis.asyncio.Redis</code>.</li> <li>Dotted path to python classes.</li> <li>Only one option in <code>backoff</code> should be set.</li> </ol>"},{"location":"extensions/data/sqlalchemy/","title":"SQLAlchemy","text":"<p>The SQLAlchemy extension makes it easy to set up database connections, providing <code>AsyncEngine</code> and <code>async_sessionmaker</code> as services in the dependency injection context.</p>"},{"location":"extensions/data/sqlalchemy/#usage","title":"Usage","text":"<p>Install <code>sqlalchemy</code> extra and a database driver that supports async:</p> <pre><code>pip install selva[sqlalchemy] aiosqlite asyncpg aiomysql oracledb\n</code></pre> <p>With database drivers are installed, we can define the connections in the configuration file:</p> <pre><code>extensions:\n  - selva.ext.data.sqlalchemy # (1)\n\nmiddleware:\n  - selva.ext.data.sqlalchemy.middleware.scoped_session # (2)\n\ndata:\n  sqlalchemy:\n    connections:\n      default: # (3)\n        url: \"sqlite+aiosqlite:///var/db.sqlite3\"\n\n      postgres: # (4)\n        url: \"postgresql+asyncpg://user:pass@localhost/dbname\"\n\n      mysql: # (5)\n        url: \"mysql+aiomysql://user:pass@localhost/dbname\"\n\n      oracle: # (6)\n        url: \"oracle+oracledb_async://user:pass@localhost/DBNAME\"\n        # or \"oracle+oracledb_async://user:pass@localhost/?service_name=DBNAME\"\n</code></pre> <ol> <li>Activate the sqlalchemy extension</li> <li>Activate the scoped session middleware</li> <li>\"default\" connection will be registered without a name</li> <li>Connection registered with name \"postgres\"</li> <li>Connection registered with name \"mysql\"</li> <li>Connection registered with name \"oracle\"</li> </ol> <p>Once we define the connections, we can inject <code>AsyncEngine</code> into our services. For each connection, an instance of <code>AsyncEngine</code> will be registered, the <code>default</code> connection will be registered without a name, and the other will be registered with their respective names.</p> <pre><code>from typing import Annotated\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom selva.di import service, Inject\n\n\n@service\nclass MyService:\n    # default service\n    engine: Annotated[AsyncEngine, Inject]\n\n    # named services\n    engine_postgres: Annotated[AsyncEngine, Inject(name=\"postgres\")]\n    engine_mysql: Annotated[AsyncEngine, Inject(name=\"mysql\")]\n    engine_oracle: Annotated[AsyncEngine, Inject(name=\"oracle\")]\n</code></pre>"},{"location":"extensions/data/sqlalchemy/#scoped-session","title":"Scoped Session","text":"<p>If the <code>selva.ext.data.sqlalchemy.middleware.scoped_session</code> middleware is enabled, the <code>selva.ext.data.sqlalchemy.ScopedSession</code> service will be registered. It provides access to an instance of <code>AsyncSession</code> that is available for the duration of the request:</p> <pre><code>from typing import Annotated\nfrom sqlalchemy import text\nfrom selva.di import service, Inject\nfrom selva.ext.data.sqlalchemy import ScopedSession\n\n\n@service\nclass MyService:\n    session: Annotated[ScopedSession, Inject]\n\n    async def method(self) -&gt; int:\n        return await self.session.scalar(text(\"select 1\"))\n</code></pre> <p>The <code>ScopedSession</code> service is a proxy to an instance of <code>AsyncSession</code> that is created by the <code>selva.ext.data.sqlalchemy.middleware.scoped_session</code> middleware.</p>"},{"location":"extensions/data/sqlalchemy/#configuration","title":"Configuration","text":"<p>Database connections can also be defined with username and password separated from the url, or even with individual components:</p> <pre><code>data:\n  sqlalchemy:\n    connections:\n      default:\n        drivername: sqlite+aiosqlite\n        database: \"/var/db.sqlite3\"\n\n      postgres: # (1)\n        url: \"postgresql+asyncpg://localhost/dbname\"\n        username: user\n        password: pass\n\n      mysql: # (2)\n        drivername: mysql+aiomysql\n        host: localhost\n        port: 3306\n        database: dbname\n        username: user\n        password: pass\n\n      oracle: # (3)\n        drivername: oracle+oracledb_async\n        host: localhost\n        port: 1521\n        database: DBNAME # (4)\n        username: user\n        password: pass\n</code></pre> <ol> <li>Username and password separated from the database url</li> <li>Each component defined individually</li> <li>Query parameters can be defined in a map</li> <li>\"service_name\" query parameter can be used instead of \"database\"     <pre><code>query:\n  service_name: DBNAME\n</code></pre></li> </ol>"},{"location":"extensions/data/sqlalchemy/#using-environment-variables","title":"Using environment variables","text":"<p>It is a good practice to externalize configuration through environment variables. We can either reference the variables in the configuration or use variables with the <code>SELVA__</code> prefix, for example, <code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__DEFAULT__URL</code>.</p> configuration/settings.yaml <pre><code>data:\n  sqlalchemy:\n    connections:\n      default:\n        url: \"${DATABASE_URL}\" # (1)\n\n      other: # (2)\n        url: \"${DATABASE_URL}\"\n        username: \"${DATABASE_USERNAME}\"\n        password: \"${DATABASE_PASSWORD}\"\n\n      another: # (3)\n        drivername: \"${DATABASE_DRIVERNAME}\"\n        host: \"${DATABASE_HOST}\"\n        port: ${DATABASE_PORT}\n        database: \"${DATABASE_NAME}\"\n        username: \"${DATABASE_USERNAME}\"\n        password: \"${DATABASE_PASSWORD}\"\n</code></pre> <ol> <li>Can be define with just the environment variable <code>SELVA__DATA__SQLALCHEMY__DEFAULT__URL</code></li> <li>Can be defined with just the environment variables:<ul> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__OTHER__URL</code></li> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__OTHER__USERNAME</code></li> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__OTHER__PASSWORD</code></li> </ul> </li> <li>Can be defined with just the environment variables:<ul> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__ANOTHER__DRIVERNAME</code></li> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__ANOTHER__HOST</code></li> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__ANOTHER__PORT</code></li> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__ANOTHER__DATABASE</code></li> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__ANOTHER__USERNAME</code></li> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__ANOTHER__PASSWORD</code></li> </ul> </li> </ol>"},{"location":"extensions/data/sqlalchemy/#working-with-async_sessionmaker","title":"Working with async_sessionmaker","text":"<p>Different from the <code>AsyncEngine</code>, Selva only creates a single <code>async_sessionmaker</code>. We can bind specific subclasses of <code>DeclarativeBase</code> through the <code>data.sqlalchemy.session.binds</code> configuration, otherwise it is bound to just the <code>default</code> connection.</p> application/model.pyconfiguration/settings.yaml <pre><code>from sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass OtherBase(DeclarativeBase):\n    pass\n</code></pre> <pre><code>data:\n  sqlalchemy:\n    connections:\n      default:\n        url: \"sqlite+aiosqlite://db1.sqlite3\"\n      other:\n        url: \"sqlite+aiosqlite://db2.sqlite3\"\n    session:\n      binds:\n        application.model.Base: default\n        application.model.OtherBase: other\n</code></pre>"},{"location":"extensions/data/sqlalchemy/#example","title":"Example","text":"application/handler.pyapplication/model.pyconfiguration/settings.yaml <pre><code>from sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import async_sessionmaker, AsyncEngine\n\nfrom asgikit.responses import respond_json\n\nfrom selva.di import Inject\nfrom selva.web import get\n\nfrom .model import Base, MyModel\n\n\n@get\nasync def index(\n    request,\n    engine: Annotated[AsyncEngine, Inject],\n    sessionmaker: Annotated[async_sessionmaker, Inject],\n):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    async with sessionmaker() as session:\n        my_model = MyModel(name=\"MyModel\")\n        session.add(my_model)\n        await session.commit()\n\n    async with sessionmaker() as session:\n        my_model = await session.scalar(select(MyModel).limit(1))\n        await respond_json(request.response, {\n            \"id\": my_model.id,\n            \"name\": my_model.name,\n        })\n</code></pre> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass MyModel(Base):\n    __tablename__ = 'my_model'\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String(length=100))\n\n    def __repr__(self):\n        return f\"&lt;MyModel(id={self.id}, name={self.name})&gt;\"\n</code></pre> <pre><code>data:\n  sqlalchemy:\n    default:\n      url: \"sqlite+aiosqlite://:memory:\"\n</code></pre>"},{"location":"extensions/data/sqlalchemy/#configuration-options","title":"Configuration options","text":"<p>Selva offers several options to configure SQLAlchemy. If you need more control over the SQLAlchemy services, you can create your own <code>AsyncEngine</code> and <code>async_sessionmaker</code> services.</p> <p>The available options are shown below:</p> <pre><code>data:\n  sqlalchemy:\n    session:\n      options: # (1)\n        class: sqlalchemy.ext.asyncio.AsyncSession\n        autoflush: true\n        expire_on_commit: true\n        autobegin: true\n        twophase: false\n        enable_baked_queries: true\n        info: # (2)\n          field: \"value\"\n        # info: \"package.module.variable\"\n        query_cls: \"sqlalchemy.orm.query.Query\" # dotted path to a python class\n        join_transaction_mode: \"conditional_savepoint\" # or \"rollback_only\", \"control_fully\", \"create_savepoint\"\n        close_resets_only: null\n      binds: # (3)\n        application.model.Base: default\n        application.model.OtherBase: other\n    connections:\n      default:\n        url: \"\"\n        options: # (4)\n          connect_args: \"package.module.variable\" # (5)\n          echo: false\n          echo_pool: false\n          enable_from_linting: false\n          hide_parameters: false\n          insertmanyvalues_page_size: 1\n          isolation_level: \"\"\n          json_deserializer: \"json.loads\" # dotted path to the json deserialization function\n          json_serializer: \"json.dumps\" # dotted path to the json serialization function\n          label_length: 1\n          logging_name: \"\"\n          max_identifier_length: 1\n          max_overflow: 1\n          module: \"\"\n          paramstyle: \"qmark\" # or \"numeric\", \"named\", \"format\", \"pyformat\"\n          poolclass: \"sqlalchemy.pool.Pool\" # dotted path to the pool class\n          pool_logging_name: \"\"\n          pool_pre_ping: false\n          pool_size: 1\n          pool_recycle: 3600\n          pool_reset_on_return: \"rollback\" # or \"commit\"\n          pool_timeout: 1\n          pool_use_lifo: false\n          plugins:\n            - \"plugin1\"\n            - \"plugin2\"\n          query_cache_size: 1\n          use_insertmanyvalues: false\n          execution_options: # (5)\n            logging_token: \"\"\n            isolation_level: \"\"\n            no_parameters: false\n            stream_results: false\n            max_row_buffer: 1\n            yield_per: 1\n            insertmanyvalues_page_size: 1\n            schema_translate_map:\n              null: \"my_schema\"\n              some_schema: \"other_schema\"\n</code></pre> <ol> <li>Values are describe in <code>sqlalchemy.orm.Session</code></li> <li>Can be a mapping or a dotted path to a python variable containing a <code>dict</code></li> <li>Binds subclasses of <code>sqlalchemy.orm.DeclarativeBase</code> to connection names defined in <code>connections</code></li> <li>Values are described in <code>sqlalchemy.create_engine</code></li> <li><code>connect_args</code> is a dotted path to a <code>dict[str, Any]</code> that will be provided     as args to the <code>connect</code> function of the underlying driver</li> <li><code>execution_options</code> values are describe in <code>Sqlalchemy.engine.Connection.execution_options</code></li> </ol>"},{"location":"extensions/templates/jinja/","title":"Jinja","text":"<p>This extension provides support for Jinja templates.</p>"},{"location":"extensions/templates/jinja/#usage","title":"Usage","text":"<p>To use jinja templates, first install the <code>jinja</code> extra:</p> <pre><code>pip install selva[jinja]\n</code></pre> <p>Then activate the extension in the configuration file:</p> <pre><code>extensions:\n  - selva.ext.templates.jinja\n</code></pre> <p>To render templates, inject the <code>selva.ext.templates.jinja.JinjaTemplate</code> dependency and call its <code>respond</code> method:</p> application.pyresources/templates/index.html <pre><code>from typing import Annotated\nfrom selva.di import Inject\nfrom selva.ext.templates.jinja import JinjaTemplate\nfrom selva.web import get\n\n@get\nasync def index(request, template: Annotated[JinjaTemplate, Inject]):\n    context = {\"title\": \"Index\"}\n    await template.respond(request.response, \"index.html\", context)\n</code></pre> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Jinja Templates&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;{{ title }}&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"extensions/templates/jinja/#render-templates-to-string","title":"Render templates to string","text":"<p>The <code>JinjaTemplate</code> class provide methods to render templates into a <code>str</code>, instead of rendering to the response.</p> <p>The method <code>JinjaTempate.render</code> accepts a template name and returns a string with the rendered template.</p> <p>The method <code>JinjaTempate.render_str</code> accepts a template string, compiles it and returns the result.</p> <pre><code>rendered = template.render(\"template.html\", {\"variable\": \"value\"})\nrendered = template.render_str(\"{{ variable }}\", {\"variable\": \"value\"})\n</code></pre>"},{"location":"extensions/templates/jinja/#configuration","title":"Configuration","text":"<p>Jinja can be configured through the <code>settings.yaml</code>. For example, to activate Jinja extensions:</p> <pre><code>templates:\n  jinja:\n    extensions:\n      - jinja2.ext.i18n\n      - jinja2.ext.debug\n</code></pre> <p>Full list of settings:</p> <pre><code>templates:\n  jinja:\n    paths:\n      - resources/templates\n    block_start_string: \"\"\n    block_end_string: \"\"\n    variable_start_string: \"\"\n    variable_end_string: \"\"\n    comment_start_string: \"\"\n    comment_end_string: \"\"\n    line_statement_prefix: \"\"\n    line_comment_prefix: \"\"\n    trim_blocks: true\n    lstrip_blocks: true\n    newline_sequence: \"\\n\" # or \"\\r\\n\" or \"\\r\"\n    keep_trailing_newline: true\n    extensions:\n      - extension1\n      - extensions2\n    optimized: true\n    # dotted path to python class\n    undefined: \"package.module.Class\"\n    # dotted path to python function\n    finalize: \"package.module.function\"\n    # dotted path to python function\n    autoescape: \"package.module.function\"\n    # dotted path to python variable\n    loader: \"package.module:variable\"\n    cache_size: 1\n    auto_reload: true\n    # dotted path to python variable\n    bytecode_cache: \"package.module:variable\"\n</code></pre>"},{"location":"extensions/templates/mako/","title":"Mako","text":"<p>This extension provides support for Mako templates.</p>"},{"location":"extensions/templates/mako/#usage","title":"Usage","text":"<p>To use mako templates, first install the <code>mako</code> extra:</p> <pre><code>pip install selva[mako]\n</code></pre> <p>Then activate the extension in the configuration file:</p> <pre><code>extensions:\n  - selva.ext.templates.mako\n</code></pre> <p>To render templates, inject the <code>selva.ext.templates.mako.MakoTemplate</code> dependency and call its <code>respond</code> method:</p> application.pyresources/templates/index.html <pre><code>from typing import Annotated\nfrom selva.di import Inject\nfrom selva.ext.templates.mako import MakoTemplate\nfrom selva.web import get\n\n@get\nasync def index(request, template: Annotated[MakoTemplate, Inject]):\n    context = {\"title\": \"Index\"}\n    await template.respond(request.response, \"index.html\", context)\n</code></pre> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Jinja Templates&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;${title}&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"extensions/templates/mako/#render-templates-to-string","title":"Render templates to string","text":"<p>The <code>MakoTemplate</code> class provide methods to render templates into a <code>str</code>, instead of rendering to the response.</p> <p>The method <code>MakoTempate.render</code> accepts a template name and returns a string with the rendered template.</p> <p>The method <code>MakoTempate.render_str</code> accepts a template string, compiles it and returns the result.</p> <pre><code>rendered = template.render(\"template.html\", {\"variable\": \"value\"})\nrendered = template.render_str(\"${variable}\", {\"variable\": \"value\"})\n</code></pre>"},{"location":"extensions/templates/mako/#configuration","title":"Configuration","text":"<p>Mako can be configured through the <code>settings.yaml</code>. For example, to activate filesystem checks:</p> <pre><code>templates:\n  mako:\n    directories:\n      - resources/mako\n    filesystem_checks: true\n</code></pre> <p>Full list of settings:</p> <pre><code>templates:\n  mako:\n    directories:\n      - resources/templates\n    module_directory: \"\"\n    filesystem_checks: false\n    collection_size: 100\n    format_exceptions: false\n    # dotted path to a python function\n    error_handler: \"package.module.function\"\n    encoding_errors: \"strict\" # or \"ignore\", \"replace\", \"xmlcharrefreplace\", \"htmlentityreplace\"\n    cache_enabled: true\n    cache_impl: \"beaker\"\n    # dotted path to a python variable\n    cache_args: \"package.module:variable\"\n    # dotted path to a python function\n    modulename_callable: \"package.module.function\"\n    # dotted path to a python function\n    module_writer: \"package.module.function\"\n    default_filters: []\n    buffer_filters: []\n    strict_undefined: false\n    imports: []\n    future_imports: []\n    enable_loop: true\n    input_encoding: \"utf-8\"\n    # dotted path to a python function\n    preprocessor: \"package.module.function\"\n    # dotted path to a python class\n    lexer_cls: \"package.module.Class\"\n    # dotted path to a python function\n    include_error_handler: \"package.module.function\"\n</code></pre>"},{"location":"middleware/overview/","title":"Middleware","text":"<p>The middleware pipeline is configured with the <code>middleware</code> configuration property. It must contain a list of functions that receive the next app in the pipeline, the settings object and the dependency injection container and must return a plain asgi middleware instance:</p> <pre><code>def middleware_factory(app, settings, di):\n    async def inner(scope, receive, send):\n        await app(scope, receive, send)\n\n    return inner\n</code></pre> <p>Any asgi middleware can be used in the middleware pipeline. For instance, it is possible to use the SessionMiddleware from starlette:</p> application/middleware.pyconfiguration/settings.yaml <pre><code>from starlette.middleware.sessions import SessionMiddleware\n\n\ndef session_middleware(app, settings, di):\n    return SessionMiddleware(app, secret_key=settings.session.secret_key)\n</code></pre> <pre><code>middleware:\n  - application.middleware:session_middleware\n\nsession:\n  secret_key: super_secret_key\n</code></pre>"},{"location":"middleware/overview/#usage","title":"Usage","text":"<p>To demonstrate the middleware system, we will create a timing middleware that will output to the console the time spent in the processing of the request:</p> application/handler.pyapplication/middleware.pyconfiguration/settings.yaml <pre><code>from asgikit.requests import Request\nfrom asgikit.responses import respond_json\nfrom selva.web import get\n\n\n@get\nasync def hello(request: Request):\n    await respond_json(request.response, {\"greeting\": \"Hello, World!\"})\n</code></pre> <pre><code>from collections.abc import Callable\nfrom datetime import datetime\n\nimport structlog\n\nfrom selva.di import service\n\nlogger = structlog.get_logger()\n\n\ndef timing_middleware(app, settings, di):\n    async def inner(scope, receive, send):\n        request_start = datetime.now()\n        await app(scope, receive, send)\n        request_end = datetime.now()\n\n        delta = request_end - request_start\n        logger.info(\"request duration\", duration=str(delta))\n    return inner\n</code></pre> <pre><code>middleware:\n  - application.middleware.timing_middleware\n</code></pre>"},{"location":"middleware/overview/#middleware-dependencies","title":"Middleware dependencies","text":"<p>Middleware functions can use the provided dependency injection container to get services the middleware might need. We could rewrite the timing middleware to persist the timings using a service instead of printing to the console:</p> application/middleware.pyapplication/service.py <pre><code>from datetime import datetime\n\nfrom application.service import TimingService\n\n\nclass TimingMiddleware:\n    def __init__(self, app, timing_service: TimingService):\n        self.timing_service = timing_service\n\n    async def __call__(self, scope, receive, send):\n        request_start = datetime.now()\n        await app(scope, receive, send)\n        request_end = datetime.now()\n\n        await self.timing_service.save(request_start, request_end)\n\n\nasync def timing_middleware(app, settings, di):\n    timing_service = await di.get(TimingService)\n    return TimingMiddleware(app, timing_service)\n</code></pre> <pre><code>from datetime import datetime\n\nfrom selva.di import service\n\n@service\nclass TimingService:\n    async def save(start: datetime, end: datetime):\n        ...\n</code></pre>"},{"location":"middleware/staticfiles_uploads/","title":"Static and uploaded files","text":"<p>The <code>static_files_middleware</code> and <code>uploaded_files_middleware</code> provide a way of serving static content and user uploaded files.</p> <p>There are two separate middlewares to allow distinct handling in the middleware pipeline. For example, you could set the uploaded files to be served after authorization, while the static files remain publicly accessible.</p>"},{"location":"middleware/staticfiles_uploads/#usage","title":"Usage","text":"<p>First you need to activate the middlewares in the <code>settings.yaml</code></p> <pre><code>middleware:\n  # ...\n  - selva.web.middleware.files.static_files_middleware\n  - selva.web.middleware.files.uploaded_files_middleware\n  # ...\n</code></pre> <p>After that, files located in the directories <code>resources/static</code> and <code>resources/uploads</code> will be served at <code>/static/</code> and <code>/uploads/</code>, respectively.</p>"},{"location":"middleware/staticfiles_uploads/#static-files-mappings","title":"Static files mappings","text":"<p>You can map specific paths to single static files in order to, for example, serve the favicon at <code>/favicon.ico</code> pointing to a file in <code>resources/static/</code>:</p> <pre><code>middleware:\n  - selva.web.middleware.files.static_files_middleware\nstaticfiles:\n  mappings:\n    favicon.ico: my-icon.ico\n</code></pre>"},{"location":"middleware/staticfiles_uploads/#configuration-options","title":"Configuration options","text":"<p>The available options to configure the <code>static_files_middleware</code> and <code>uploaded_files_middleware</code> are shown below:</p> <pre><code>staticfiles:\n    path: /static # (1)\n    root: resources/static # (2)\n    mappings: {}\n\nuploadedfiles:\n    path: /uploads # (3)\n    root: resources/uploads # (4)\n</code></pre> <ol> <li>Path where static files are served</li> <li>Directory where static files are located</li> <li>Path where uploaded files are served</li> <li>Directory where uploaded files are located</li> </ol>"},{"location":"pt/","title":"Selva","text":"<p>Selva \u00e9 uma ferramenta para criar aplica\u00e7\u00f5es ASGI que s\u00e3o f\u00e1ceis de construir e manter.</p> <p>\u00c9 baseado na biblioteca asgikit e tem um sistema de inje\u00e7\u00e3o de depend\u00eancia atrav\u00e9s de anota\u00e7\u00f5es de tipo do Python. \u00c9 compat\u00edvel com Python 3.11+.</p>"},{"location":"pt/#comecando","title":"Come\u00e7ando","text":"<p>Instale <code>selva</code> e <code>uvicorn</code>:</p> <pre><code>pip install selva uvicorn[standard]\n</code></pre> <p>Crie o arquivo <code>application.py</code>:</p> <pre><code>from asgikit.requests import Request\nfrom asgikit.responses import respond_text\nfrom selva.web import get\n\n\n@get\nasync def hello(request: Request):\n    await respond_text(request.response, \"Hello, World\")\n</code></pre> <p>Execute a aplica\u00e7\u00e3o with <code>uvicorn</code>. Selva vai carregar automaticamente o <code>application.py</code>:</p> <pre><code>uvicorn selva.run:app\n</code></pre> <pre><code>INFO:     Started server process [1000]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n</code></pre>"},{"location":"pt/background/","title":"Servi\u00e7os em plano de fundo","text":"<p>H\u00e1 casos onde voc\u00ea precisa executar c\u00f3digo em paralelo a sua aplica\u00e7\u00e3o, por exemplo, escutar por mensagens em uma fila.</p> <p>Selva prov\u00ea o decorador <code>selva.web.background</code> para fun\u00e7\u00f5es como servi\u00e7os em plano de fundo que ser\u00e1 iniciados como tarefas ass\u00edncronas em paralelo \u00e0 aplica\u00e7\u00e3o principal.</p> <pre><code>from selva.web import background\n\n\n@background\nasync def background_service():\n    ...\n</code></pre> <p>As fun\u00e7\u00f5es de plano de fundo podem receber servi\u00e7os como par\u00e2metros do sistema de inje\u00e7\u00e3o de depden\u00eancias.</p> <p>Por exemplo, voc\u00ea pode criar um servi\u00e7o que escuta por noticia\u00e7\u00f5es do Redis: </p> <pre><code>from redis.asyncio import Redis\nfrom selva.web import background\nimport structlog\n\nlogger = structlog.get_logger()\n\n\n@background\nasync def listen_channel(redis: Redis):\n    async with redis.pubsub() as pubsub:\n        await pubsub.psubscribe(\"chat\")\n        while True:\n            if message := await pubsub.get_message(\n                ignore_subscribe_messages=True,\n                timeout=None\n            ):\n                logger.info(\"chat\", message=message[\"data\"].decode())\n</code></pre>"},{"location":"pt/configuration/","title":"Configura\u00e7\u00e3o","text":"<p>Configura\u00e7\u00f5es em Selva s\u00e3o definidas atrav\u00e9s de arquivos YAML. Internamente \u00e9 utilizado a biblioteca ruamel.yaml, ent\u00e3o YAML 1.2 \u00e9 suportado.</p> <p>Arquivos de configura\u00e7\u00e3o s\u00e3o localizados por padr\u00e3o no diret\u00f3rio <code>configuration</code> com o nome base de <code>settings.yaml</code>:</p> <pre><code>project/\n\u251c\u2500\u2500 application/\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 configuration/\n    \u251c\u2500\u2500 settings.yaml\n    \u251c\u2500\u2500 settings_dev.yaml\n    \u2514\u2500\u2500 settings_prod.yaml\n</code></pre>"},{"location":"pt/configuration/#acessando-as-configuracoes","title":"Acessando as configura\u00e7\u00f5es","text":"<p>Os valores de configura\u00e7\u00e3o pode ser acessados ao injetar <code>selva.configuration.Settings</code>.</p> <pre><code>from typing import Annotated\nfrom selva.configuration import Settings\nfrom selva.di import Inject, service\n\n\n@service\nclass MyService:\n    settings: Annotated[Settings, Inject]\n</code></pre> <p>O objeto <code>Settings</code> funciona como um <code>dict</code> que pode ser acessado com a sintaxe de acesso \u00e0 propriedades:</p> <pre><code>from selva.configuration import Settings\n\nsettings = Settings({\"config\": \"value\"})\nassert settings[\"config\"] == \"value\"\nassert settings.config == \"value\"\n</code></pre>"},{"location":"pt/configuration/#configuracoes-tipadas","title":"Configura\u00e7\u00f5es tipadas","text":"<p>Configura\u00e7\u00f5es carregadas de arquivos YAML s\u00e3o todos <code>dict</code>. Entretando, n\u00f3s podemos utilizar o <code>pydantic</code> e o sistema de inje\u00e7\u00e3o de depend\u00eancias para prover acesso \u00e0s configura\u00e7\u00f5es de uma forma mais tipada.</p> application.pyconfiguration/settings.yaml <pre><code>from pydantic import BaseModel\nfrom selva.configuration import Settings\nfrom selva.di import service\n\n\nclass MySettings(BaseModel):\n    int_property: int\n    bool_property: bool\n\n\n@service\ndef my_settings(settings: Settings) -&gt; MySettings:\n    return MySettings.model_validate(settings.my_settings)\n</code></pre> <pre><code>my_settings:\n  int_property: 1\n  bool_property: true\n</code></pre>"},{"location":"pt/configuration/#substituicao-de-ambiente","title":"Substitui\u00e7\u00e3o de ambiente","text":"<p>Os arquivos de configura\u00e7\u00f5es podem incluir refer\u00eancias a vari\u00e1veis de ambiente no formato <code>${ENV_VAR:default_value}</code>. O valor padr\u00e3o \u00e9 opcional e um erro ser\u00e1 lan\u00e7ado se ambos vari\u00e1vel de ambiente e valor padr\u00e3o n\u00e3o forem definidos.</p> <pre><code>required: ${ENV_VAR}         # vari\u00e1vel de ambiente requerida\noptional: ${OPT_VAR:default} # vari\u00e1vel de ambiente opcional\n</code></pre>"},{"location":"pt/configuration/#perfis","title":"Perfis","text":"<p>Perfis opcionais podem ser ativados ao definir a vari\u00e1vel de ambiente <code>SELVA_PROFILE</code>. O framework procurar\u00e1 por um arquivos chamado <code>settings_${SELVA_PROFILE}.yaml</code> e combinar\u00e1 os valores com aqueles do <code>settings.yaml</code>. Valores do perfil tem preced\u00eancia sobre os valores da configura\u00e7\u00e3o principal.</p> <p>Por exemplo, se n\u00f3s definirmos <code>SELVA_PROFILE=dev</code>, o arquivos <code>settings_dev.yaml</code> ser\u00e1 carregado. Mas se ao inv\u00e9s n\u00f3s definirmos <code>SELVA_PROFILE=prod</code>, ent\u00e3o o arquivo <code>settings_prod.yaml</code> ser\u00e1 carregado.</p> <p>M\u00faltiplos perfis podem ser ativados ao definir <code>SELVA_PROFILE</code> com uma lista separada por v\u00edrgula de pergis, por exemplo <code>SELVA_PROFILE=dev,prod</code>. O framework vai iterar pela lista de combinar as configura\u00e7\u00f5es encontradas em cada um. A preced\u00eacia \u00e9 do \u00faltimo para o primeiro, ent\u00e3o as configura\u00e7\u00f5es do primeiro perfil sobrescrevem as do perfil anterior.</p>"},{"location":"pt/configuration/#variaveis-de-ambiente","title":"Vari\u00e1veis de ambiente","text":"<p>Configura\u00e7\u00f5es tamb\u00e9m podem ser definidas em vari\u00e1veis de ambiente cujos nomes come\u00e7am com <code>SELVA__</code>, onde subsequentes underscores duplos (<code>__</code>) indicam aninhamento (a vari\u00e1vel \u00e9 um mapeamento). Al\u00e9m disso, nomes de vari\u00e1veis ser\u00e3o transformados em letras min\u00fasculas.</p> <p>Por exemplo, considere as seguintes vari\u00e1veis de ambiente:</p> <pre><code>SELVA__PROPERTY=1\nSELVA__MAPPING__PROPERTY=2\nSELVA__MAPPING__ANOTHER_PROPERTY=3\n</code></pre> <p>Essas vari\u00e1veis ser\u00e3o coletadas da seguinte forma:</p> <pre><code>{\n    \"property\": \"1\",\n    \"mapping\": {\n        \"property\": \"2\",\n        \"another_property\": \"3\",\n    },\n}\n</code></pre>"},{"location":"pt/configuration/#dotenv","title":"DotEnv","text":"<p>Se estiver executando seu projeto usando <code>selva.run:app</code>, por exemplo, <code>uvicorn selva.run:app</code>, vari\u00e1veis de ambiente ser\u00e1o carregadas do arquivo <code>.env</code>. O parsing \u00e9 realizado com a biblioteca python-dotenv.</p> <p>Por padr\u00e3o, o arquivos<code>.env</code> no diret\u00f3rio atual ser\u00e1 carregado, mas ele pode ser customizado com a vari\u00e1vel de ambiente <code>SELVA_DOTENV</code> apontando para o arquivo <code>.env</code>.</p>"},{"location":"pt/handlers/#visao-geral","title":"Vis\u00e3o geral","text":"<p>Handlers s\u00e3o fun\u00e7\u00f5es respons\u00e1veis por tratar as requisi\u00e7\u00f5es recebidas. Eles s\u00e3o definidos com os decoradores <code>@get</code>, <code>@post</code>, <code>@put</code>, <code>@patch</code>, <code>@delete</code> and <code>@websocket</code>.</p> <p>Handlers devem receber, pelo menos, o objeto da requisi\u00e7\u00e3o como primeiro par\u00e2metro. N\u00e3o \u00e9 necess\u00e1rio anotar o par\u00eametro, mas ele deve ser o primeiro.</p> <pre><code>from asgikit.requests import Request, read_json\nfrom asgikit.responses import respond_text, respond_redirect\nfrom selva.web import get, post\nimport structlog\n\nlogger = structlog.get_logger()\n\n\n@get\nasync def index(request: Request):\n    await respond_text(request.response, \"application root\")\n\n\n@post(\"send\")\nasync def handle_data(request: Request):\n    content = await read_json(request)\n    logger.info(\"request body\", content=repr(content))\n    await respond_redirect(request.response, \"/\")\n</code></pre> <p>Nota</p> <p>Definir um caminho em <code>@get @post etc...</code> \u00e9 opcional e tem valor padr\u00e3o de string vazia <code>\"\"</code>.</p> <p>Handlers podem ser definidas com par\u00e2metros de caminho, que ser\u00e3o ligadas ao handler com a anota\u00e7\u00e3o <code>FromPath</code>:</p> <pre><code>from typing import Annotated\nfrom selva.web import get, FromPath\n\n\n@get(\"/:path_param\")\ndef handler(request, path_param: Annotated[str, FromPath]):\n    ...\n</code></pre> <p>Tamb\u00e9m \u00e9 poss\u00edvel declarar explicitamente de qual par\u00e2metro o valor ser\u00e1 recuperado:</p> <pre><code>from typing import Annotated\nfrom selva.web import get, FromPath\n\n\n@get(\"/:path_param\")\ndef handler(request, value: Annotated[str, FromPath(\"path_param\")]):\n    ...\n</code></pre> <p>A se\u00e7\u00e3o de roteamento prov\u00ea mais informa\u00e7\u00f5es sobre par\u00e2metros de caminho.</p>"},{"location":"pt/handlers/#respostas","title":"Respostas","text":"<p>Herdando o <code>asgikit.responses.Response</code> de <code>asgikit</code>, os handlers n\u00e3o retornam uma resposta, ao inv\u00e9s disso elas escrevem os dados na resposta.</p> <pre><code>from asgikit.requests import Request\nfrom asgikit.responses import respond_json\nfrom selva.web import get\n\n\n@get\nasync def handler(request: Request):\n    await respond_json(request.response, {\"data\": \"The response\"})\n</code></pre> <p><code>asgikit</code> prov\u00ea fun\u00e7\u00f5es para escrever dados na resposta:</p> <pre><code>from collections.abc import AsyncIterable\nfrom http import HTTPStatus\n\nfrom asgikit.responses import Response\n\n\nasync def respond_text(response: Response, content: str | bytes): ...\nasync def respond_status(response: Response, status: HTTPStatus): ...\nasync def respond_redirect(response: Response, location: str, permanent: bool = False): ...\nasync def respond_redirect_post_get(response: Response, location: str): ...\nasync def respond_json(response: Response, content): ...\nasync def stream_writer(response: Response): ...\nasync def respond_stream(response: Response, stream: AsyncIterable[bytes | str]): ...\n</code></pre>"},{"location":"pt/handlers/#dependencias","title":"Depend\u00eancias","text":"<p>Handlers podem receber servi\u00e7os como par\u00e2metros que ser\u00e3o injetados quando o handler \u00e9 chamado:</p> <pre><code>from typing import Annotated\nfrom selva.di import service, Inject\nfrom selva.web import get\n\n\n@service\nclass MyService:\n    pass\n\n\n@get\ndef my_handler(request, my_service: Annotated[MyService, Inject]):\n    ...\n</code></pre>"},{"location":"pt/handlers/#informacoes-da-requisicao","title":"Informa\u00e7\u00f5es da requisi\u00e7\u00e3o","text":"<p>Handlers recebem um objeto do tipo <code>asgikit.requests.Request</code> como primeiro par\u00e2metro que prov\u00ea acesso \u00e0s informa\u00e7\u00f5es da requisi\u00e7\u00e3o (caminho, m\u00e9todo, cabe\u00e7alhos, query string, corpo da requisi\u00e7\u00e3o). Ele tamb\u00e9m prov\u00ea o objeto <code>asgikit.responses.Response</code> ou <code>asgikit.websockets.WebSocket</code> para responder \u00e0 requisi\u00e7\u00e3o ou interagir com o cliente atrav\u00e9s do websocket.</p> <p>Aten\u00e7\u00e3o</p> <p>For http requests, <code>Request.websocket</code> will be <code>None</code>, and for websocket requests, <code>Request.response</code> will be <code>None</code></p> <pre><code>from http import HTTPMethod, HTTPStatus\nfrom asgikit.requests import Request\nfrom asgikit.responses import respond_json\nfrom selva.web import get, websocket\n\n\n@get\nasync def handler(request: Request):\n    assert request.response is not None\n    assert request.websocket is None\n\n    assert request.method == HTTPMethod.GET\n    assert request.path == \"/\"\n    await respond_json(request.response, {\"status\": HTTPStatus.OK})\n\n@websocket\nasync def ws_handler(request: Request):\n    assert request.response is None\n    assert request.websocket is not None\n\n    ws = request.websocket\n    await ws.accept()\n    while True:\n        data = await ws.receive()\n        await ws.send(data)\n</code></pre>"},{"location":"pt/handlers/#corpo-da-requisicao","title":"Corpo da requisi\u00e7\u00e3o","text":"<p><code>asgikit</code> prov\u00ea v\u00e1rias fun\u00e7\u00f5es para recuperar o corpo da requisi\u00e7\u00e3o:</p> <pre><code>from asgikit.requests import Body, Request\nfrom python_multipart import multipart\n\n\nasync def read_body(request: Body | Request) -&gt; bytes: ...\nasync def read_text(request: Body | Request, encoding: str = None) -&gt; str: ...\nasync def read_json(request: Body | Request) -&gt; dict | list: ...\nasync def read_form(request: Body | Request) -&gt; dict[str, str | multipart.File]: ...\n</code></pre>"},{"location":"pt/handlers/#websockets","title":"Websockets","text":"<p>Para websockets, h\u00e1 as seguintes fun\u00e7\u00f5es:</p> <pre><code>from collections.abc import Iterable\n\n\nasync def accept(subprotocol: str = None, headers: Iterable[tuple[str, str | list[str]]] = None): ...\nasync def receive(self) -&gt; str | bytes: ...\nasync def send(self, data: bytes | str): ...\nasync def close(self, code: int = 1000, reason: str = \"\"): ...\n</code></pre>"},{"location":"pt/handlers/#parametros-da-requisicao","title":"Par\u00e2metros da requisi\u00e7\u00e3o","text":"<p>Handlers podem receber par\u00e2metros adicionais, os quais ser\u00e3o extra\u00eddos da requisi\u00e7\u00e3o utilizando uma implementa\u00e7\u00e3o de <code>selva.web.FromRequest[T]</code>. Se n5\u00e3o houver uma implementa\u00e7\u00e3o direta de <code>FromRequest[T]</code>, Selva procurar\u00e1 nos tipos base de <code>T</code> at\u00e9 que uma implementa\u00e7\u00e3o seja encontrada ou um erro ser\u00e1 retornado.</p> <p>Voc\u00ea pode usar o decorador <code>register_from_request</code> para registrar uma implementa\u00e7\u00e3o de <code>FromRequest</code>.</p> <pre><code>from asgikit.requests import Request\nfrom asgikit.responses import respond_text\nfrom selva.web import get\nfrom selva.web.converter.decorator import register_from_request\n\n\nclass Param:\n    def __init__(self, path: str):\n        self.request_path = path\n\n\n@register_from_request(Param)\nclass ParamFromRequest:\n    def from_request(\n        self,\n        request: Request,\n        original_type,\n        parameter_name,\n        metadata,\n        optional,\n    ) -&gt; Param:\n        return Param(request.path)\n\n\n@get\nasync def handler(request: Request, param: Param):\n    await respond_text(request.response, param.request_path)\n</code></pre> <p>Se a implementa\u00e7\u00e3o de <code>FromRequest</code> lan\u00e7ar um erro, o handler n\u00e3o \u00e9 chamado. E se o erro for uma subclassse de <code>selva.web.error.HTTPError</code>, por exemplo <code>HTTPUnauthorizedException</code>, uma resposta ser\u00e1 produzida de acordo como o erro.</p> <pre><code># ...\nfrom selva.web.exception import HTTPUnauthorizedException\n\n\n@register_from_request(Param)\nclass ParamFromRequest:\n    def from_request(\n        self,\n        request: Request,\n        original_type,\n        parameter_name,\n        metadata,\n        optional,\n    ) -&gt; Param:\n        if \"authorization\" not in request.headers:\n            raise HTTPUnauthorizedException()\n        return Param(context.path)\n</code></pre>"},{"location":"pt/handlers/#parametros-anotados","title":"Par\u00e2metros anotados","text":"<p>Se o par\u00e2metro for anotado (<code>Annotated[T, U]</code>) o framework procurar\u00e1 for uma implementa\u00e7\u00e3o de <code>FromRequest[U]</code>, com <code>T</code> sendo passado como o par\u00e2metro <code>original_type</code> e <code>U</code> como o par\u00e2metro <code>metadata</code>.</p>"},{"location":"pt/handlers/#pydantic","title":"Pydantic","text":"<p>Selva j\u00e1 implementa <code>FromRequest[pydantic.BaseModel]</code> lendo o corpo da requisi\u00e7\u00e3o e carregando os dados no modelo pydantic, se o tipo de conte\u00fado for json ou formul\u00e1rio, caso contr\u00e1rio ser\u00e1 lan\u00e7ado um <code>HTTPError</code> com c\u00f3digo de status 415. Tamb\u00e9m \u00e9 fornecida uma implementa\u00e7\u00e3o para <code>list[pydantic.BaseModel]</code>.</p>"},{"location":"pt/logging/","title":"Logging","text":"<p>Selva usa Structlog para logging e prov\u00ea algumas facilidades para tornar seu uso mais pr\u00f3ximo de outros frameworks como Spring Boot.</p> <p>Ele \u00e9 integrado com o logging da biblioteca padr\u00e3o, ent\u00e3o bibliotecas que a usam realizar\u00e3o logging com Structlog. Ele tamb\u00e9m permite filtrar pelo nome do logger usando a biblioteca padr\u00e3o.</p>"},{"location":"pt/logging/#porque","title":"Porque?","text":"<p>Atualmente, \u00e9 muito prov\u00e1vel que sua aplica\u00e7\u00e3o seja implantada em uma nuvem e os logs enviados para um agregador como Greylog, ent\u00e3o um formato de logging estruturado parece ser a escolha mais l\u00f3gica.</p> <p>Para mais informa\u00e7\u00f5es sobre o porqu\u00ea de usar logging estruturado, veja Structlog documentation.</p>"},{"location":"pt/logging/#configure-o-logging","title":"Configure o logging","text":"<p>O logging \u00e9 configurado atrav\u00e9s da configura\u00e7\u00e3o do Selva:</p> <pre><code>logging:\n  root: WARNING # (1)\n  level: # (2)\n    application: INFO\n    selva: DEBUG\n  format: json # (3) \n  setup: selva.logging.setup # (4)\n</code></pre> <ol> <li>N\u00edvel de log do logger raiz.</li> <li>Mapa de nomes de loggers para o n\u00edvel de log.</li> <li>Formato do log. Poss\u00edveis valores s\u00e3o <code>\"json\"</code>, <code>\"logfmt\"</code>, <code>\"keyvalue\"</code> e <code>\"console\"</code>.</li> <li>Setup function to configure logging.</li> </ol> <p>A configura\u00e7\u00e3o <code>format</code> define quanl renderer ser\u00e1 utilizado. Os poss\u00edvel valores apontam para o seguinte:</p> value renderer <code>json</code> <code>structlog.processors.JSONRenderer()</code> <code>logfmt</code> <code>structlog.processors.LogfmtRenderer(bool_as_flag=True)</code> <code>keyvalue</code> <code>structlog.processors.KeyValueRenderer()</code> <code>console</code> <code>structlog.dev.ConsoleRenderer()</code> <p>Se n\u00e3o definido, <code>format</code> ter\u00e1 o valor de <code>\"json\"</code> se <code>sys.stderr.isatty() == False</code>, caso contr\u00e1rio ter\u00e1 o valor <code>\"console\"</code>. Isto \u00e9 feito para utilizar <code>ConsoleRenderer</code> em desenvolvimento e <code>JSONRenderer</code> quando implantado em produ\u00e7\u00e3o</p>"},{"location":"pt/logging/#definicao-manual-do-logger","title":"Defini\u00e7\u00e3o manual do logger","text":"<p>Se voc\u00ea precisar de controle total de como o Structlog \u00e9 configurado, voc\u00ea pode fornecer uma fun\u00e7\u00e3o de defini\u00e7\u00e3o de logger. Voc\u00ea precisa apenas referenci\u00e1-la no arquivo de configura\u00e7\u00e3o:</p> configuration/settings.yamlapplication/logging.py <pre><code>logging:\n  setup: application.logging.setup\n</code></pre> <pre><code>import structlog\nfrom selva.configuration import Settings\n\n\ndef setup(settings: Settings):\n    structlog.configure(...)\n</code></pre> <p>A fun\u00e7\u00e3o de defini\u00e7\u00e3o recebe um par\u00e2metro do tipo <code>selva.configuration.Settings</code>, ent\u00e3o voc\u00ea ter\u00e1 acesso a todas as configura\u00e7\u00f5es.</p>"},{"location":"pt/routing/","title":"Roteamento","text":"<p>Roteamento \u00e9 definido pelos decoradores nos handlers.</p>"},{"location":"pt/routing/#parametros-de-caminho","title":"Par\u00e2metros de caminho","text":"<p>Par\u00e2metros podem ser definidos no caminho dos handlers utilizando a sintaxe <code>:parameter_name</code>, onde <code>parameter_name</code> deve ser o nome do argumento na assinatura do handler.</p> <pre><code>from typing import Annotated\nfrom asgikit.requests import Request\nfrom asgikit.responses import respond_text\nfrom selva.web import get, FromPath\n\n\n@get(\"hello/:name\")\nasync def handler(request: Request, name: Annotated[str, FromPath]):\n    await respond_text(request.response, f\"Hello, {name}!\")\n</code></pre> <p>Aqui foi usado <code>Annotated</code> e <code>FromPath</code> para indicar que o argumento do handler deve ser vinculado ao par\u00e2metro do caminho da requisi\u00e7\u00e3o. Mais sobre isso ser\u00e1 explicado nas se\u00e7\u00f5es seguintes.</p>"},{"location":"pt/routing/#correspondencia-de-caminho","title":"Correspond\u00eancia de caminho","text":"<p>O comportamento padr\u00e3o \u00e9 o par\u00e2metro de caminho corresponder a apenas um \u00fanico seguimento. Se voc\u00ea quiser corresponder ao caminho completo, ou a um subcaminho do caminho da requisi\u00e7\u00e3o, utilize a sintaxe <code>*parameter_name</code>.</p> <pre><code>from typing import Annotated\nfrom asgikit.requests import Request\nfrom asgikit.responses import respond_text\nfrom selva.web import get, FromPath\n\n\n@get(\"hello/*path\")\nasync def handler(request: Request, path: Annotated[str, FromPath]):\n    name = \" \".join(path.split(\"/\"))\n    await respond_text(request.response, f\"Hello, {name}!\")\n</code></pre> <p>Para uma requisi\u00e7\u00e3o como <code>GET hello/Python/World</code>, o handler retornar\u00e1 <code>Hello, Python World!</code>.</p> <p>Voc\u00ea pode combinar ambos os tipos de par\u00e2metros sem problemas:</p> <ul> <li><code>*path</code></li> <li><code>*path/literal_segment</code></li> <li><code>:normal_param/*path</code></li> <li><code>:normal_param/*path/:other_path</code></li> </ul>"},{"location":"pt/routing/#conversao-de-parametros","title":"Convers\u00e3o de par\u00e2metros","text":"<p>A convers\u00e3o de par\u00e2metros \u00e9 realizada atrav\u00e9s de anota\u00e7\u00f5es de tipo nos par\u00e2metros. O framework tentar\u00e1 encontrar um conversor adequado ao tipo do par\u00e2metro e ent\u00e3o converter o valor antes de chamar o handler.</p> <pre><code>from typing import Annotated\nfrom asgikit.requests import Request\nfrom asgikit.responses import respond_json\nfrom selva.web import get, FromPath\n\n\n@get(\"repeat/:amount\")\nasync def handler(request: Request, amount: Annotated[int, FromPath]):\n    await respond_json(request.response, {f\"repeat {i}\": i for i in range(amount)})\n</code></pre> <p>O framework procurar\u00e1 por um servi\u00e7o que implementa <code>selva.web.converter.from_request.FromRequest[FromPath]</code> para recuperar os dados da requisi\u00e7\u00e3o, ent\u00e3o esse servi\u00e7o procurar\u00e1 por um conversor, um servi\u00e7o que implementa <code>selva.web.converter.Converter[str, int]</code> para converter os dados para o tipo requisitado.</p> <p>Selva prov\u00ea conversores para os tipos <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code> e <code>pathlib.PurePath</code>.</p>"},{"location":"pt/routing/#coversao-de-parametros-customizada","title":"Covers\u00e3o de par\u00e2metros customizada","text":"<p>A convers\u00e3o pode ser customizada ao prover uma implementa\u00e7\u00e3o de <code>selva.web.converter.Converter</code>. Voc\u00ea normalmente utilizar\u00e1 como atalho o decorador <code>selva.web.converter.decorator.register_converter.</code></p> <pre><code>from dataclasses import dataclass\nfrom typing import Annotated\n\nfrom asgikit.requests import Request\nfrom asgikit.responses import respond_text\nfrom selva.web import get, FromPath\nfrom selva.web.converter.decorator import register_converter\n\n\n@dataclass\nclass MyModel:\n    name: str\n\n\n@register_converter(str, MyModel)\nclass MyModelParamConverter:\n    def convert(self, value: str) -&gt; MyModel:\n        return MyModel(value)\n\n\n@get(\"/:model\")\nasync def handler(request: Request, model: Annotated[MyModel, FromPath]):\n    await respond_text(request.response, str(model))\n</code></pre> <p>Se a implementa\u00e7\u00e3o de <code>Converter</code> lan\u00e7ar um erro, o handler n\u00e3o ser\u00e1 chamado. E se o erro for uma subclasse de <code>selva.web.error.HTTPError</code>, por exemplo, <code>HTTPUnauthorizedException</code>, uma resposta ser\u00e1 produzida de acordo com o erro.</p>"},{"location":"pt/services/","title":"Servi\u00e7os","text":"<p>Servi\u00e7os s\u00e3o tipos registrados no cont\u00eainer de inje\u00e7\u00e3o de depend\u00eancias que podem ser injetados em outros servi\u00e7os e handlers. Eles s\u00e3o definidos com o decorador <code>@service</code>.</p> <pre><code>from typing import Annotated\nfrom selva.di import Inject, service\n\n\n@service\nclass MyService:\n    pass\n\n\n@service\nclass MyOtherService:\n    dependency: Annotated[MyService, Inject]\n\n\nclass SomeClass:\n    pass\n\n\nclass OtherClass:\n    def __init__(self, dependency: SomeClass):\n        self.dependency = dependency\n\n\n@service\nasync def factory() -&gt; SomeClass:\n    return SomeClass()\n\n\n@service\nasync def other_factory(dependency: SomeClass) -&gt; OtherClass:\n    return OtherClass(dependency)\n</code></pre>"},{"location":"pt/services/#servicos-como-classes","title":"Servi\u00e7os como classes","text":"<p>Servi\u00e7os definidos como classes tem depend\u00eancias como anota\u00e7\u00f5es da classe.</p> <pre><code>from typing import Annotated\nfrom selva.di import Inject, service\n\n\n@service\nclass MyService:\n    pass\n\n\n@service\nclass OtherService:\n    property: Annotated[MyService, Inject]\n</code></pre> <p>Quando um servi\u00e7o de um tipo \u00e9 requisitado no cont\u00eainer de inje\u00e7\u00e3o de depend\u00eancias, a classe ser\u00e1 inspecionada pelas depend\u00eancias anotadas que ser\u00e3o criadas e injetadas no servi\u00e7o requisitado.</p> <p>Anota\u00e7\u00f5es sem <code>Inject</code> ser\u00e3o ignoradas.</p>"},{"location":"pt/services/#inicializadores-e-finalizadores","title":"Inicializadores e finalizadores","text":"<p>Opcionalmente, classes de servi\u00e7os podem definir dois m\u00e9todos: <code>initialize()</code>, que ser\u00e1 chamado ap\u00f3s a cria\u00e7\u00e3o do servi\u00e7o e inje\u00e7\u00e3o das depend\u00eancias; e <code>finalize()</code>, que ser\u00e1 chamado na finaliza\u00e7\u00e3o da aplica\u00e7\u00e3o.</p> <pre><code>from selva.di import service\n\n\n@service\nclass MyService:\n    async def initialize(self):\n        \"\"\"executa l\u00f3gica de inicializa\u00e7\u00e3o\"\"\"\n\n    async def finalize(self):\n        \"\"\"executa l\u00f3gica de finaliza\u00e7\u00e3o\"\"\"\n</code></pre> <p>Os m\u00e9todos <code>initialize()</code> e <code>finalize()</code> n\u00e3o precisam ser <code>async</code>.</p>"},{"location":"pt/services/#servicos-que-proveem-uma-interface","title":"Servi\u00e7os que proveem uma interface","text":"<p>Voc\u00ea pode ter servi\u00e7os que proveem uma interface ao inv\u00e9s do seu pr\u00f3prio tipo, de forma que voc\u00ea requisita a interface como depend\u00eancia ao inv\u00e9s do tipo concreto.</p> <pre><code>from typing import Annotated\n\nfrom selva.di import Inject, service\n\n\nclass Interface:\n    def some_method(self): pass\n\n\n@service(provides=Interface)\nclass MyService:\n    def some_method(self): pass\n\n\n@service\nclass OtherService:\n    dependency: Annotated[Interface, Inject]\n</code></pre> <p>Quando <code>OtherService</code> for criado, o cont\u00eainer de inje\u00e7\u00e3o de depend\u00eancias procurar\u00e1 por um servi\u00e7o do tipo <code>Interface</code> e produzir\u00e1 uma inst\u00e2ncia da classe <code>MyService</code>.</p>"},{"location":"pt/services/#servicos-nomeados","title":"Servi\u00e7os nomeados","text":"<p>Servi\u00e7os podem ser registrados com um nome, de forma que voc\u00ea pode ter mais de um servi\u00e7o do mesmo tipo, desde que tenham nomes distintos. Sem um nome, o servi\u00e7o \u00e9 registrado como o padr\u00e3o para aquele tipo.</p> <pre><code>from typing import Annotated\n\nfrom selva.di import Inject, service\n\n\nclass Interface: pass\n\n\n@service(name=\"A\", provides=Interface)\nclass ServiceA: pass\n\n\n@service(name=\"B\", provides=Interface)\nclass ServiceB: pass\n\n\n@service\nclass OtherService:\n    dependency_a: Annotated[Interface, Inject(name=\"A\")]\n    dependency_b: Annotated[Interface, Inject(name=\"B\")]\n</code></pre>"},{"location":"pt/services/#dependencias-opcionais","title":"Depend\u00eancias opcionais","text":"<p>Se uma depend\u00eancia requisitada n\u00e3o for registrada, um erro \u00e9 lan\u00e7ado, a n\u00e3o ser que haja um valor padr\u00e3o declarado, onde a propriedade ter\u00e1 esse valor quando o servi\u00e7o for criado.</p> <pre><code>from typing import Annotated\n\nfrom selva.di import Inject, service\n\n\n@service\nclass SomeService:\n    pass\n\n\n@service\nclass MyService:\n    dependency: Annotated[SomeService, Inject] = None\n\n    def some_method(self):\n        if self.dependency:\n            ...\n</code></pre>"},{"location":"pt/services/#servicos-como-funcoes-geradoras","title":"Servi\u00e7os como fun\u00e7\u00f5es geradoras","text":"<p>Para registrar um tipo que n\u00f3s n\u00e3o temos controle, por exemplo, um tipo de uma biblioteca externa, n\u00f3s podemos uma uma fun\u00e7\u00e3o geradora:</p> <pre><code>from selva.di import service\nfrom some_library import SomeClass\n\n\n@service\nasync def some_class_factory() -&gt; SomeClass:\n    return SomeClass()\n</code></pre> <p>A anota\u00e7\u00e3o de tipo de retorno \u00e9 requirida em fun\u00e7\u00f5es geradoras, j\u00e1 que esta ser\u00e1 o servi\u00e7o provido pela fun\u00e7\u00e3o. Se a anota\u00e7\u00e3o de tipo de retorno n\u00e3o for provida, um erro ser\u00e1 lan\u00e7ado.</p> <p>O valor do par\u00e2metro <code>provides</code> em <code>@service</code> \u00e9 ignorado quando estiver decorando uma fun\u00e7\u00e3o geradora, e um warning ser\u00e1 lan\u00e7ado.</p> <p>Par\u00e2metros de fun\u00e7\u00f5es geradoras n\u00e3o precisam da anota\u00e7\u00e3o <code>Inject</code>, a n\u00e3o ser que elas precisem especificar uma depend\u00eancia nomeada.</p> <pre><code>from typing import Annotated\n\nfrom selva.di import Inject, service\nfrom some_library import SomeClass\n\n\n@service\nasync def some_class_factory(\n    dependency: MyService,\n    other: Annotated[OtherService, Inject(name=\"service_name\")]\n) -&gt; SomeClass:\n    return SomeClass()\n</code></pre>"},{"location":"pt/services/#inicializacao-e-finalizacao","title":"Inicializa\u00e7\u00e3o e finaliza\u00e7\u00e3o","text":"<p>Para executar inicializa\u00e7\u00e3o em fun\u00e7\u00f5es geradoras, voc\u00ea apenas executa a l\u00f3gica antes de retornar o servi\u00e7o.</p> <pre><code>from selva.di import service\n\n\nclass SomeClass:\n    pass\n\n\n@service\nasync def factory() -&gt; SomeClass:\n    some_service = SomeClass()\n    # perform initialization login\n    return some_service\n</code></pre> <p>Para executar finaliza\u00e7\u00e3o, voc\u00ea usa <code>yield</code> ao inv\u00e9s de <code>return</code> e executa a l\u00f3gica de finaliza\u00e7\u00e3o logo ap\u00f3s</p> <pre><code>from selva.di import service\n\n\nclass SomeClass:\n    pass\n\n\n@service\nasync def factory() -&gt; SomeClass:\n    some_service = SomeClass()\n    # perform initialization logic\n    yield some_service\n    # perform finalization logic\n</code></pre>"},{"location":"pt/services/#servicos-nomeados_1","title":"Servi\u00e7os nomeados","text":"<p>Servi\u00e7os nomeados funcionam da mesma forma que nas classes.</p> <pre><code>from typing import Annotated\n\nfrom selva.di import Inject, service\n\nfrom some_library import SomeClass\n\n\n@service(name=\"service_name\")\ndef factory() -&gt; SomeClass:\n    return SomeClass\n\n\n@service\nclass MyService:\n    dependency: Annotated[SomeClass, Inject(name=\"service_name\")]\n</code></pre>"},{"location":"pt/services/#dependencias-opcionais_1","title":"Depend\u00eancias opcionais","text":"<p>Depend\u00eancias opcionais funcionam da mesma forma que nas classes, onde voc\u00ea especifica um valor padr\u00e3o para o argumento.</p> <pre><code>from typing import Annotated\n\nfrom selva.di import Inject, service\nfrom some_library import SomeClass\n\n\n@service\nasync def some_class_factory(\n    dependency: MyService,\n    other: Annotated[OtherService, Inject(name=\"service_name\")] = None\n) -&gt; SomeClass:\n    if other:\n        ...\n\n    return SomeClass()\n</code></pre>"},{"location":"pt/startup/","title":"Fun\u00e7\u00f5es de inicializa\u00e7\u00e3o","text":"<p>Selva prov\u00ea decoradores para marcas fun\u00e7\u00f5es como ganchos que ser\u00e3o chamadas quando a aplica\u00e7\u00e3o iniciar. As fun\u00e7\u00f5es ser\u00e3o chamadas na ordem em que foram descobertas e, se alguma lan\u00e7ar um erro, a aplica\u00e7\u00e3o n\u00e3o ser\u00e1 iniciada.</p> <pre><code>from selva.web import startup\n\n\n@startup\ndef my_startup_hook():\n    ...\n</code></pre> <p>Fun\u00e7\u00f5es de inicializa\u00e7\u00e3o podem receber servi\u00e7os como par\u00e2metros atrav\u00e9s do sistema de inje\u00e7\u00e3o de depend\u00eancias.</p> <pre><code>from selva.di import service\nfrom selva.web import startup\n\n\n@service\nclass OIDCService:\n    async def oidc_discovey(self):\n        ...\n\n\n@startup\nasync def my_startup_hook(oidc_service: OIDCService):\n    await oidc_service.oidc_discovey()\n</code></pre> <p>Voc\u00ea pode usar a anota\u00e7\u00e3o <code>Inject</code> se precisar de um servi\u00e7o nomeado.</p> <pre><code>from typing import Annotated\n\nfrom selva.di import Inject, service\nfrom selva.web import startup\n\n\n@service(name=\"provider\")\nclass OIDCService:\n    async def oidc_discovey(self):\n        ...\n\n\n@startup\nasync def my_startup_hook(\n    oidc_service: Annotated[OIDCService, Inject(name=\"provider\")]\n):\n    await oidc_service.oidc_discovey()\n</code></pre>"},{"location":"pt/structure/","title":"Estrutura do projeto","text":"<p>Em um projeto Selva, voc\u00ea precisa definir pelo menos o <code>application</code>.</p> <p>Pode ser um m\u00f3dulo ou um pacote Python e representa o c\u00f3digo principal do projeto. Quaisquer handlers e servi\u00e7os definidos sob ele ser\u00e3o descobertos e registrados.</p> <p>Se o seu projeto \u00e9 pequeno, voc\u00ea pode apenas definir o m\u00f3dulo <code>application.py</code>, mas voc\u00ea pode ter qualquer estrutura que quiser dentro do pacote <code>application</code>.</p> <p>Por exemplo:</p> <pre><code># m\u00ednimo\nproject/\n\u2514\u2500\u2500 application.py\n\n# com m\u00f3dulos\nproject/\n\u2514\u2500\u2500 application/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 handler.py\n    \u251c\u2500\u2500 model.py\n    \u251c\u2500\u2500 repository.py\n    \u2514\u2500\u2500 service.py\n\n# estrutura complexa\nproject/\n\u2514\u2500\u2500 application/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 handler/\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 public/\n    \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2502   \u251c\u2500\u2500 about.py\n    \u2502   \u2502   \u251c\u2500\u2500 home.py\n    \u2502   \u2502   \u2514\u2500\u2500 product.py\n    \u2502   \u2514\u2500\u2500 private/\n    \u2502       \u251c\u2500\u2500 __init__.py\n    \u2502       \u251c\u2500\u2500 category.py\n    \u2502       \u251c\u2500\u2500 customer.py\n    \u2502       \u2514\u2500\u2500 product.py\n    \u251c\u2500\u2500 model/\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 category.py\n    \u2502   \u251c\u2500\u2500 customer.py\n    \u2502   \u2514\u2500\u2500 product.py\n    \u251c\u2500\u2500 repository/\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 category.py\n    \u2502   \u251c\u2500\u2500 customer.py\n    \u2502   \u2514\u2500\u2500 product.py\n    \u2514\u2500\u2500 service/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 category.py\n        \u251c\u2500\u2500 customer.py\n        \u251c\u2500\u2500 email.py\n        \u2514\u2500\u2500 product.py\n</code></pre>"},{"location":"pt/tutorial/","title":"Tutorial","text":"<p>Vamos nos aprofundar um pouco mais e a aprender os conceitos b\u00e1sicos.</p> <p>N\u00f3s criaremos uma api de cumprimentos que salva logs das requisi\u00e7\u00f5es.</p>"},{"location":"pt/tutorial/#instalando-o-selva","title":"Instalando o Selva","text":"<p>Antes de seguir em frente, n\u00f3s precisamos instalar o Selva e Uvicorn.</p> <pre><code>pip install selva uvicorn[standard]\n</code></pre>"},{"location":"pt/tutorial/#estrutura-da-aplicacao","title":"Estrutura da aplica\u00e7\u00e3o","text":"<p>Uma aplica\u00e7\u00e3o Selva pode ser estruturada das seguintes formas:</p> <pre><code># m\u00ednimo\nproject/\n\u251c\u2500\u2500 application.py\n\u251c\u2500\u2500 configuration/\n\u2502   \u2514\u2500\u2500 settings.yaml\n\u2514\u2500\u2500 resources/\n\n# com m\u00f3dulos\nproject/\n\u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 handler.py\n\u2502   \u251c\u2500\u2500 repository.py\n\u2502   \u2514\u2500\u2500 service.py\n\u251c\u2500\u2500 configuration/\n\u2502   \u2514\u2500\u2500 settings.yaml\n\u2514\u2500\u2500 resources/\n</code></pre> <p>E \u00e9 isso! Um m\u00f3dulo ou pacote chamado <code>application</code> ser\u00e1 automaticamente importado e escaneado para encontrar os handlers e servi\u00e7os.</p> <p>Voc\u00ea ainda pode estruturar o <code>application</code> da forma que melhor te atender.</p>"},{"location":"pt/tutorial/#executando-a-aplicacao","title":"Executando a aplica\u00e7\u00e3o","text":"<p>N\u00f3s usaremos o <code>uvicorn</code> para executar a aplica\u00e7\u00e3o e automaticamente reiniciar quando fizermos mudan\u00e7as no c\u00f3digo:</p> <pre><code>$ uvicorn selva.run:app --reload\nINFO:     Will watch for changes in these directories: ['/home/user/projects/selva-tutorial']\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [1001] using WatchFiles\nINFO:     Started server process [1000]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n</code></pre>"},{"location":"pt/tutorial/#handlers","title":"Handlers","text":"<p>Handlers responder\u00e3o a requisi\u00e7\u00f5es HTTP ou WebSocket. Elas podem receber servi\u00e7os atrav\u00e9s do sistema de inje\u00e7\u00e3o de depend\u00eancias.</p> application/handler.py <pre><code>from typing import Annotated\nfrom asgikit.requests import Request\nfrom asgikit.responses import respond_json\nfrom selva.web import get, FromPath\n\n@get(\"hello/:name\") # (1)\nasync def hello(request: Request, name: Annotated[str, FromPath]):\n    await respond_json(request.response, {\"greeting\": f\"Hello, {name}!\"})\n</code></pre> <ol> <li> <p><code>@get(\"hello/:name\")</code> define a fun\u00e7\u00e3o como um handler no caminho informado.     Se um caminho n\u00e3o for fornecido, o caminho raiz (\"/\") ser\u00e1 utilizado.</p> <p><code>:name</code> define um par\u00e2metro de caminho que ser\u00e1 ligado ao par\u00e2metro <code>name</code> no handler, indicado por <code>Annotated[str, FromPath]</code>.</p> </li> </ol> <p>E agora n\u00f3s testamos se nosso handler est\u00e1 funcionando:</p> <pre><code>$ curl localhost:8000/hello/World\n{\"greeting\": \"Hello, World!\"}\n</code></pre> <p>Neste momento nosso handler apenas recebe um nome do caminho e responde com dados JSON para o cliente.</p>"},{"location":"pt/tutorial/#criando-o-servico-greeter","title":"Criando o servi\u00e7o Greeter","text":"<p>Nosso servi\u00e7o ter\u00e1 um m\u00e9todo que recebe um nome e retorna um cumprimento. Ele ser\u00e1 injetado no handler que n\u00f3s criamos anteriormente.</p> application/service.pyapplication/handler.py <pre><code>from selva.di import service\n\n\n@service # (1)\nclass Greeter:\n    def greet(self, name: str) -&gt; str:\n        return f\"Hello, {name}!\"\n</code></pre> <ol> <li><code>@service</code> registra a classe no sistema de inje\u00e7\u00e3o de depend\u00eancias para     que ele possa ser injetado em outras classes ou fun\u00e7\u00f5es handler</li> </ol> <pre><code>from typing import Annotated\nfrom asgikit.requests import Request\nfrom asgikit.responses import respond_json\nfrom selva.di import Inject\nfrom selva.web import get\nfrom .service import Greeter\n\n\n@get(\"/hello/:name\")\nasync def hello(\n    request: Request,\n    name: Annotated[str, FromPath],\n    gretter: Annotated[Gretter, Inject], # (1)\n):\n    greeting = greeter.greet(name)\n    await respond_json(request.response, {\"greeting\": greeting})\n</code></pre> <ol> <li>Injeta o servi\u00e7o <code>Greeter</code></li> </ol>"},{"location":"pt/tutorial/#adicionar-um-banco-de-dados","title":"Adicionar um banco de dados","text":"<p>Nosso servi\u00e7o de cumprimentos est\u00e1 funcionando bem, mas n\u00f3s poder\u00edamos querer registrar as requisi\u00e7\u00f5es de cumprimentos num banco de dados persistente, para realizar auditorias.</p> <p>Para fazer isso n\u00f3s precisamos criar um servi\u00e7o de banco de dados e injet\u00e1-lo no servi\u00e7o <code>Greeter</code>. Para isso n\u00f3s usaremos a biblioteca Databases com suporte a SQLite:</p> <pre><code>pip install databases[aiosqlite]\n</code></pre> <p>A biblioteca <code>databases</code> prov\u00ea uma classe chamada <code>Database</code>. No entando, n\u00f3s n\u00e3o podemos decor\u00e1-la com <code>@service</code>, ent\u00e3o precisaremos criar uma fun\u00e7\u00e3o factory:</p> application/repository.pyapplication/handler.py <pre><code>from datetime import datetime\nfrom typing import Annotated\nfrom databases import Database\nfrom selva.di import service, Inject\n\n@service # (1)\nasync def database_factory() -&gt; Database:\n    database = Database(\"sqlite:///database.sqlite3\")\n    await database.connect()\n\n    yield database\n\n    await database.disconnect()\n\n\n@service\nclass GreetingRepository:\n    database: Annotated[Database, Inject] # (2)\n\n    async def initialize(self): # (3)\n        query = \"\"\"\n            create table if not exists greeting_log(\n                greeting text not null,\n                datetime text not null\n            );\n        \"\"\"\n        await database.execute(query)\n\n    async def finalize(self): # (4)\n        query = \"drop table if exists greeting_log;\"\n        await database.execute(query)\n\n    async def save_greeting(self, greeting: str, date: datetime):\n        query = \"\"\"\n            insert into greeting_log (greeting, datetime)\n            values (:greeting, datetime(:datetime))\n        \"\"\"\n        params = {\"greeting\": greeting, \"datetime\": date}\n        await self.database.execute(query, params)\n</code></pre> <ol> <li> <p>A fun\u00e7\u00e3o decorada com <code>@service</code> \u00e9 usada para criar o servi\u00e7o quando voc\u00ea     precisa prover tipos que voc\u00ea n\u00e3o det\u00e9m o controle</p> </li> <li> <p>Injetar o servi\u00e7o <code>Database</code> no <code>GreetingRepository</code></p> </li> <li> <p>O m\u00e9todo chamado <code>initialize</code> ser\u00e1 chamado ap\u00f3s o servi\u00e7o ser constru\u00eddo     para executar qualquer l\u00f3gica de inicializa\u00e7\u00e3o</p> </li> <li> <p>O m\u00e9todo chamado <code>finalize</code> ser\u00e1 chamado antes que o servi\u00e7o seja destru\u00eddo     para executar qualquer l\u00f3gica de finaliza\u00e7\u00e3o.</p> </li> </ol> <pre><code>from typing import Annotated\nfrom datetime import datetime\nfrom asgikit.requests import Request\nfrom asgikit.responses import respond_json\nfrom selva.di import Inject\nfrom selva.web import get, FromPath\nfrom .repository import GreetingRepository\nfrom .service import Greeter\n\n\n@get(\"hello/:name\")\nasync def hello_name(\n    request: Request,\n    name: Annotated[str, FromPath],\n    greeter: Annotated[Greeter, Inject],\n    repository: Annotated[GreetingRepository, Inject],\n):\n    greeting = greeter.greet(name)\n    await repository.save_greeting(greeting, datetime.now())\n    await respond_json(request.response, {\"greeting\": greeting})\n</code></pre>"},{"location":"pt/tutorial/#executar-acoes-apos-o-envio-da-resposta","title":"Executar a\u00e7\u00f5es ap\u00f3s o envio da resposta","text":"<p>Os cumprimentos est\u00e3o sendo salvos no banco de dados, mas agora n\u00f3s temos um problema: O usu\u00e1rio precisa esperar at\u00e9 que o cumprimento seja salvo antes de receb\u00ea-lo.</p> <p>Para resolver esse problema e melhorar a experi\u00eancia do usu\u00e1rio, n\u00f3s podemos salvar o cumprimento ap\u00f3s a requisi\u00e7\u00e3o ser conclu\u00edda:</p> application/handler.py <pre><code>from datetime import datetime\nfrom typing import Annotated\nfrom asgikit.requests import Request\nfrom asgikit.responses improt respond_json\nfrom selva.di import Inject\nfrom selva.web import get, FromPath\nfrom .repository import GreetingRepository\nfrom .service import Greeter\n\n\n@get(\"hello/:name\")\nasync def hello_name(\n    request: Request,\n    name: Annotated[str, FromPath],\n    greeter: Annotated[Greeter, Inject],\n    repository: Annotated[GreetingRepository, Inject],\n):\n    greeting = greeter.greet(name)\n    await respond_json(request.response, {\"greeting\": greeting})  # (1)\n\n    await repository.save_greeting(greeting, datetime.now())  # (2)\n</code></pre> <ol> <li> <p>A chamada a <code>respond_json</code> conclui a resposta</p> </li> <li> <p>O cumprimento \u00e9 salvo ap\u00f3s a resposta ser enviada</p> </li> </ol>"},{"location":"pt/tutorial/#recuperando-os-logs-de-cumprimentos","title":"Recuperando os logs de cumprimentos","text":"<p>Para ver os cumprimentos salvos no banco de dados, n\u00f3s precisamos apenas adicionar um handler para recuperar os logs e retorn\u00e1-los:</p> application/repository.pyapplication/handler.py <pre><code>@service\nclass GreetingRepository:\n    # ...\n    async def get_greetings(self) -&gt; list[tuple[str, str]]:\n        query = \"\"\"\n            select l.greeting, datetime(l.datetime) from greeting_log l\n            order by rowid desc\n        \"\"\"\n        result = await self.database.fetch_all(query)\n        return [{\"greeting\": r.greeting, \"datetime\": r.datetime} for r in result]\n</code></pre> <pre><code># ...\n@get(\"/logs\")\nasync def greeting_logs(\n    request: Request,\n    repository: Annotated[GreetingRepository, Inject],\n):\n    greetings = await repository.get_greetings()\n    await respond_json(request.response, greetings)\n</code></pre> <p>Agora n\u00f3s podemos tentar requisitar alguns cumprimentos e recuperar os logs:</p> <pre><code>$ curl localhost:8000/hello/Python\n{\"greeting\": \"Hello, Python!\"}\n\n$ curl localhost:8000/hello/World\n{\"greeting\": \"Hello, World!\"}\n\n$ curl -s localhost:8000/logs | python -m json.tool\n[\n    {\n        \"greeting\": \"Hello, World!\",\n        \"datetime\": \"2025-01-01 12:00:10\"\n    },\n    {\n        \"greeting\": \"Hello, Python!\",\n        \"datetime\": \"2025-01-01 12:00:20\"\n    },\n]\n</code></pre>"},{"location":"pt/tutorial/#recebendo-dados-de-post","title":"Recebendo dados de post","text":"<p>N\u00f3s tamb\u00e9m podemos enviar o nome no corpo da requisi\u00e7\u00e3o, ao inv\u00e9s da url, e usar o Pydantic para tratar o corpo da requisi\u00e7\u00e3o:</p> application/models.pyapplication/handler.py <pre><code>from pydantic import BaseModel\n\n\nclass GreetingRequest(BaseModel):\n    name: str\n</code></pre> <pre><code># ...\nfrom selva.web import FromBody\nfrom .model import GreetingRequest\n\n# ...\n\n@post(\"hello\")\nasync def hello_post(\n    request: Request,\n    greeting_request: Annotated[GreetingRequest, FromBody],\n    greeter: Annotated[Greeter, Inject],\n    repository: Annotated[GreetingRepository, Inject],\n):\n    name = greeting_request.name\n    greeting = greeter.greet(name)\n    await respond_json(request.response, {\"greeting\": greeting})\n    await repository.save_greeting(greeting, datetime.now())\n</code></pre> <p>E para testar:</p> <pre><code>$ curl -H 'Content-Type: application/json' -d '{\"name\": \"World\"}' localhost:8000/hello\n{\"greeting\": \"Hello, World!\"}\n</code></pre>"},{"location":"pt/extensions/overview/","title":"Extens\u00f5es","text":"<p>Extens\u00f5es s\u00e3o pacotes python que prov\u00eaem funcionalidade adicional ou integram bibliotecas externas com o framework.</p> <p>As extens\u00f5es providas s\u00e3o:</p> <ul> <li>Bancos de dados<ul> <li>SQLAlchemy</li> <li>Redis</li> <li>Memcached</li> </ul> </li> <li>Templates<ul> <li>Jinja</li> <li>Mako</li> </ul> </li> </ul>"},{"location":"pt/extensions/overview/#ativando-extensoes","title":"Ativando extens\u00f5es","text":"<p>Extens\u00f5es precisam ser ativada no <code>settings.yaml</code>, na propriedade <code>extensions</code>:</p> <pre><code>extensions:\n- selva.ext.data.sqlalchemy\n- selva.ext.templates.jinja\n</code></pre>"},{"location":"pt/extensions/overview/#criando-extensoes","title":"Criando extens\u00f5es","text":"<p>Uma extens\u00e3o \u00e9 um pacote ou m\u00f3dulo que cont\u00e9m uma fun\u00e7\u00e3o chamada <code>init_extension</code> que recebe os argumentos <code>selva.di.Container</code> e <code>selva.configuration.Settings</code>. Ela \u00e9 chamada durante a inicializa\u00e7\u00e3o da aplica\u00e7\u00e3o e pode ser uma fun\u00e7\u00e3o ass\u00edncrona.</p> <pre><code>from selva.configuration import Settings\nfrom selva.di import Container\n\nasync def init_extension(container: Container, settings: Settings):\n    pass\n\n# # init_extension n\u00e3o precisa ser ass\u00edncrona\n# def init_extension(container: Container, settings: Settings): ...\n</code></pre> <p>A fun\u00e7\u00e3o pode ent\u00e3o acessar valores no objeto de configura\u00e7\u00e3o, registrar servi\u00e7os, recuperar o servi\u00e7o roteador para registrar novas rotas, etc.</p>"},{"location":"pt/extensions/data/memcached/","title":"Memcached","text":"<p>Essa extens\u00e3o prov\u00ea suporte para conectar a servidores Memcached. Ela registra o servi\u00e7o <code>aiomcache.Client</code>.</p>"},{"location":"pt/extensions/data/memcached/#utilizacao","title":"Utiliza\u00e7\u00e3o","text":"<p>Primeiro instale o extra <code>memcached</code>:</p> <pre><code>pip install selva[memcached]\n</code></pre> <p>Defina as propriedade de configura\u00e7\u00e3o:</p> configuration/settings.yaml <pre><code>extensions:\n  - selva.ext.data.memcached # (1)\n\ndata:\n  memcached:\n    default: # (2)\n      address: \"localhost:11211\"\n    other: # (3)\n      address: \"localhost:11212\"\n</code></pre> <ol> <li>Ativar a extens\u00e3o</li> <li>A conex\u00e3o \"default\" ser\u00e1 registrada sem um nome</li> <li>Conex\u00e3o registrada com nome \"other\"</li> </ol> <p>Injete o servi\u00e7o <code>aiomcache.Client</code>:</p> <pre><code>from typing import Annotated\nfrom aiomcache import Client as Memcached\nfrom selva.di import service, Inject\n\n\n@service\nclass MyService:\n    # default service\n    memcached: Annotated[Memcached, Inject]\n\n    # named service\n    other_memcached: Annotated[Memcached, Inject(name=\"other\")]\n</code></pre>"},{"location":"pt/extensions/data/memcached/#utilizando-variaveis-de-ambiente","title":"Utilizando vari\u00e1veis de ambiente","text":"configuration/settings.yaml <pre><code>data:\n  memcached:\n    default:\n      address: \"${MEMCACHED_ADDR}\" # (1)\n</code></pre> <ol> <li>Pode ser definido com a vari\u00e1vel de ambiente <code>SELVA__DATA__MEMCACHED__DEFAULT__ADDRESS</code></li> </ol>"},{"location":"pt/extensions/data/memcached/#examplo","title":"Examplo","text":"application/handler.pyconfiguration/settings.yaml <pre><code>from typing import Annotated\n\nfrom aiomcache import Client as Memcached\n\nfrom asgikit.responses import respond_json\n\nfrom selva.di import Inject\nfrom selva.web import get\n\n@get\nasync def index(request, memcached: Annotated[Memcached, Inject]):\n    if not await memcached.get(b\"number\"):\n        await memcached.set(b\"number\", b\"0\")\n    number = await memcached.incr(\"number\")\n    await respond_json(request.response, {\"number\": number})\n</code></pre> <pre><code>data:\n  memcached:\n    default:\n      address: \"localhost:11211\"\n</code></pre>"},{"location":"pt/extensions/data/memcached/#opcoes-de-configuracao","title":"Op\u00e7\u00f5es de configura\u00e7\u00e3o","text":"<p>Selva oferece v\u00e1rias op\u00e7\u00f5es para configurar Memcached. Se voc\u00ea precisar de mais controle sobre o servi\u00e7o do Memcached, voc\u00ea pode criar o seu pr\u00f3prio servi\u00e7o <code>aiomcache.Client</code>.</p> <p>As op\u00e7\u00f5es dispon\u00edveis s\u00e3o exibidas abaixo:</p> <pre><code>data:\n  memcached:\n    default:\n      address: \"\"\n      options:\n        pool_size: 10\n        pool_minsize: 1\n        get_flat_handler: \"package.module.function\" # (1)\n        set_flat_handler: \"package.module.function\" # (2)\n        conn_args: \"package.module:variable\" # (3)\n</code></pre> <ol> <li>caminho para uma fun\u00e7\u00e3o python</li> <li>caminho para uma fun\u00e7\u00e3o python</li> <li>caminho para uma vari\u00e1vel python</li> </ol>"},{"location":"pt/extensions/data/redis/","title":"Redis","text":"<p>Esta extens\u00e3o prov\u00ea suporte para conectar a servidores Redis. Ela registra o servi\u00e7o <code>redis.asyncio.Redis</code>.</p>"},{"location":"pt/extensions/data/redis/#utilizacao","title":"Utiliza\u00e7\u00e3o","text":"<p>Primeiro instale o extra <code>redis</code>:</p> <pre><code>pip install selva[redis]\n</code></pre> <p>Defina as propriedades de configura\u00e7\u00e3o:</p> configuration/settings.yaml <pre><code>extensions:\n  - selva.ext.data.redis # (1)\n\ndata:\n  redis:\n    default: # (2)\n      url: redis://localhost:6379/0\n    other: # (3)\n      url: redis://localhost:6379/1\n</code></pre> <ol> <li>Ativar a extens\u00e3o</li> <li>A conex\u00e3o \"default\" ser\u00e1 registrada sem um nome</li> <li>Conex\u00e3o registrada com nome \"other\"</li> </ol> <p>Injete o servi\u00e7o <code>Redis</code>:</p> <pre><code>from typing import Annotated\nfrom redis.asyncio import Redis\nfrom selva.di import service, Inject\n\n\n@service\nclass MyService:\n    # default service\n    redis: Annotated[Redis, Inject]\n\n    # named service\n    other_redis: Annotated[Redis, Inject(name=\"other\")]\n</code></pre> <p>Conex\u00f5es Redis tamb\u00e9m podem ser definidas com nome de usu\u00e1rio e senha separados da url, ou at\u00e9 como componentes individuais:</p> configuration/settings.yaml <pre><code>data:\n  redis:\n    url_username_password: # (1)\n      url: redis://localhost:6379/0\n      username: user\n      password: pass\n\n    individual_components: # (2)\n      host: localhost\n      port: 6379\n      db: 0\n      username: user\n      password: pass\n</code></pre> <ol> <li>Nome de usu\u00e1rio e senha separados da url</li> <li>Cada componente definido individualmente</li> </ol>"},{"location":"pt/extensions/data/redis/#utilizando-variaveis-de-ambiente","title":"Utilizando vari\u00e1veis de ambiente","text":"configuration/settings.yaml <pre><code>data:\n  redis:\n    default:\n      url: \"${REDIS_URL}\" # (1)\n\n    other: # (2)\n      url: \"${REDIS_URL}\"\n      username: \"${REDIS_USERNAME}\"\n      password: \"${REDIS_PASSWORD}\"\n\n    another: # (3)\n      host: \"${REDIS_HOST}\"\n      port: ${REDIS_PORT}\n      db: \"${REDIS_DB}\"\n      username: \"${REDIS_USERNAME}\"\n      password: \"${REDIS_PASSWORD}\"\n</code></pre> <ol> <li>Pode ser definido com a vari\u00e1vel de ambiente <code>SELVA__DATA__REDIS__DEFAULT__URL</code></li> <li>Pode ser definido com as vari\u00e1veis de ambiente:<ul> <li><code>SELVA__DATA__REDIS__OTHER__URL</code></li> <li><code>SELVA__DATA__REDIS__OTHER__USERNAME</code></li> <li><code>SELVA__DATA__REDIS__OTHER__PASSWORD</code></li> </ul> </li> <li>Pode ser definido com as vari\u00e1veis de ambiente:<ul> <li><code>SELVA__DATA__REDIS__ANOTHER__HOST</code></li> <li><code>SELVA__DATA__REDIS__ANOTHER__PORT</code></li> <li><code>SELVA__DATA__REDIS__ANOTHER__DB</code></li> <li><code>SELVA__DATA__REDIS__ANOTHER__USERNAME</code></li> <li><code>SELVA__DATA__REDIS__ANOTHER__PASSWORD</code></li> </ul> </li> </ol>"},{"location":"pt/extensions/data/redis/#exemplo","title":"Exemplo","text":"application/handler.pyconfiguration/settings.yaml <pre><code>from typing import Annotated\n\nfrom redis.asyncio import Redis\n\nfrom asgikit.responses import respond_json\n\nfrom selva.di import Inject\nfrom selva.web import get\n\n@get\nasync def index(request, redis: Annotated[Redis, Inject]):\n    number = await redis.incr(\"number\")\n    await respond_json(request.response, {\"number\": number})\n</code></pre> <pre><code>data:\n  redis:\n    default:\n      url: \"redis://localhost:6379/0\"\n</code></pre>"},{"location":"pt/extensions/data/redis/#opcoes-de-configuracao","title":"Op\u00e7\u00f5es de configura\u00e7\u00e3o","text":"<p>Selva ofecere v\u00e1rias op\u00e7\u00f5es para configura o Redis. Se voc\u00ea precisar de mais controle sobre o servi\u00e7o Redis, voc\u00ea pode criar o seu pr\u00f3prio servi\u00e7o <code>redis.asyncio.Redis</code>.</p> <p>As op\u00e7\u00f5es dispon\u00edveis s\u00e3o mostradas abaixo:</p> <pre><code>data:\n  redis:\n    default:\n      url: \"\"\n      host: \"\"\n      port: 6379\n      db: 0\n      username: \"\"\n      password: \"\"\n      options: # (1)\n        socket_timeout: 1.0\n        socket_connect_timeout: 1.0\n        socket_keepalive: false\n        socket_keepalive_options:\n          TCP_KEEPIDLE: 100,\n          TCP_KEEPCNT: 100,\n          TCP_KEEPINTVL: 100,\n        unix_socket_path: \"\"\n        encoding: \"\"\n        encoding_errors: \"strict\" # ou \"ignore\", \"replace\"\n        decode_responses: false\n        retry_on_timeout: false\n        retry_on_error: []\n        ssl: false\n        ssl_keyfile: \"\"\n        ssl_certfile: \"\"\n        ssl_cert_reqs: \"\"\n        ssl_ca_certs: \"\"\n        ssl_ca_data: \"\"\n        ssl_check_hostname: false\n        max_connections: 1\n        single_connection_client: false \n        health_check_interval: 1\n        client_name: \"\"\n        lib_name: \"\"\n        lib_version: \"\"\n        auto_close_connection_pool: false\n        protocol: 3\n        retry:\n          retries: 1\n          supported_errors: # (2)\n            - package.module.Class\n          backoff: # (3)\n            no_backoff:\n            constant:\n              backoff: 1\n            exponential:\n              cap: 1\n              base: 1\n            full_jitter:\n              cap: 1\n              base: 1\n            equal_jitter:\n              cap: 1\n              base: 1\n            decorrelated_jitter:\n              cap: 1\n              base: 1\n</code></pre> <ol> <li>Valores de <code>options</code> s\u00e3o descritos em <code>redis.asyncio.Redis</code>.</li> <li>Caminho para classes python.</li> <li>Apenas uma op\u00e7\u00e3o em <code>backoff</code> deve ser definida.</li> </ol>"},{"location":"pt/extensions/data/sqlalchemy/","title":"SQLAlchemy","text":"<p>A estens\u00e3o do SQLAlchemy facilita a configura\u00e7\u00e3o de conex\u00f5es com bancos de dados, provendo os <code>AsyncEngine</code> e <code>async_sessionmaker</code> como servi\u00e7os no context de inje\u00e7\u00e3o de depend\u00eancias.</p>"},{"location":"pt/extensions/data/sqlalchemy/#utilizacao","title":"Utiliza\u00e7\u00e3o","text":"<p>Instale o extra <code>sqlalchemy</code> e um driver de banco de dados que suporta async:</p> <pre><code>pip install selva[sqlalchemy] aiosqlite asyncpg aiomysql oracledb\n</code></pre> <p>Com os drivers instalados, n\u00f3s podemos definir as conex\u00f5es no arquivo de configura\u00e7\u00e3o:</p> <pre><code>extensions:\n  - selva.ext.data.sqlalchemy # (1)\n\nmiddleware:\n  - selva.ext.data.sqlalchemy.middleware.scoped_session # (2)\n\ndata:\n  sqlalchemy:\n    connections:\n      default: # (3)\n        url: \"sqlite+aiosqlite:///var/db.sqlite3\"\n\n      postgres: # (4)\n        url: \"postgresql+asyncpg://user:pass@localhost/dbname\"\n\n      mysql: # (5)\n        url: \"mysql+aiomysql://user:pass@localhost/dbname\"\n\n      oracle: # (6)\n        url: \"oracle+oracledb_async://user:pass@localhost/DBNAME\"\n        # ou \"oracle+oracledb_async://user:pass@localhost/?service_name=DBNAME\"\n</code></pre> <ol> <li>Ativar a extens\u00e3o sqlalchemy</li> <li>Ativar o middleware de scoped session</li> <li>A conex\u00e3o \"default\" ser\u00e1 registrada sem um nome</li> <li>Conex\u00e3o registrada com nome \"postgres\"</li> <li>Conex\u00e3o registrada com nome \"mysql\"</li> <li>Conex\u00e3o registrada com nome \"oracle\"</li> </ol> <p>Uma vez definidas as conex\u00f5es, n\u00f3s podemos injetar <code>AsyncEngine</code> nos nossos servi\u00e7os. Para cada conex\u00e3o, uma inst\u00e2ncia de <code>AsyncEngine</code> ser\u00e1 registrada, a conex\u00e3o <code>default</code> ser\u00e1 registrada sem um nome, e as outras conex\u00f5es ser\u00e3o registradas com seus respectivos nomes.</p> <pre><code>from typing import Annotated\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom selva.di import service, Inject\n\n\n@service\nclass MyService:\n    # default service\n    engine: Annotated[AsyncEngine, Inject]\n\n    # named services\n    engine_postgres: Annotated[AsyncEngine, Inject(name=\"postgres\")]\n    engine_mysql: Annotated[AsyncEngine, Inject(name=\"mysql\")]\n    engine_oracle: Annotated[AsyncEngine, Inject(name=\"oracle\")]\n</code></pre>"},{"location":"pt/extensions/data/sqlalchemy/#scoped-session","title":"Scoped Session","text":"<p>Se o middleware <code>selva.ext.data.sqlalchemy.middleware.scoped_session</code> for ativado, o servi\u00e7o <code>selva.ext.data.sqlalchemy.ScopedSession</code> ser\u00e1 registrado. Ele prov\u00ea acesso a uma inst\u00e2ncia de <code>AsyncSession</code> que fica dispon\u00edvel pela dura\u00e7\u00e3o da requisi\u00e7\u00e3o.</p> <pre><code>from typing import Annotated\nfrom sqlalchemy import text\nfrom selva.di import service, Inject\nfrom selva.ext.data.sqlalchemy import ScopedSession\n\n\n@service\nclass MyService:\n    session: Annotated[ScopedSession, Inject]\n\n    async def method(self) -&gt; int:\n        return await self.session.scalar(text(\"select 1\"))\n</code></pre> <p>O servi\u00e7o <code>ScopedSession</code> \u00e9 um proxy para a inst\u00e2ncia de <code>AsyncSession</code> que \u00e9 criado pelo middeware <code>selva.ext.data.sqlalchemy.middleware.scoped_session</code>.</p>"},{"location":"pt/extensions/data/sqlalchemy/#configuracao","title":"Configura\u00e7\u00e3o","text":"<p>Conex\u00f5es de bancos de dados podem ser definidas com usu\u00e1rio e senha separados da url, ou at\u00e9 com componentes individuais:</p> <pre><code>data:\n  sqlalchemy:\n    connections:\n      default:\n        drivername: sqlite+aiosqlite\n        database: \"/var/db.sqlite3\"\n\n      postgres: # (1)\n        url: \"postgresql+asyncpg://localhost/dbname\"\n        username: user\n        password: pass\n\n      mysql: # (2)\n        drivername: mysql+aiomysql\n        host: localhost\n        port: 3306\n        database: dbname\n        username: user\n        password: pass\n\n      oracle: # (3)\n        drivername: oracle+oracledb_async\n        host: localhost\n        port: 1521\n        database: DBNAME # (4)\n        username: user\n        password: pass\n</code></pre> <ol> <li>Usu\u00e1rio e senha separados da url</li> <li>Cada componente definido individualmente</li> <li>Par\u00e2metros de query podem ser definidos em um mapa</li> <li>Par\u00e2metro de query \"service_name\" pode ser usado ao inv\u00e9s de \"database\"     <pre><code>query:\n  service_name: DBNAME\n</code></pre></li> </ol>"},{"location":"pt/extensions/data/sqlalchemy/#utilizando-variaveis-de-ambiente","title":"Utilizando vari\u00e1veis de ambiente","text":"<p>\u00c9 uma boa pr\u00e1tia externalizar configura\u00e7\u00f5es atrav\u00e9s de vari\u00e1veis de ambiente. N\u00f3s podemos referencias vari\u00e1veis na configura\u00e7\u00e3o ou utilizar vari\u00e1veis com prefixo <code>SELVA__</code>, por exemplo, <code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__DEFAULT__URL</code>.</p> configuration/settings.yaml <pre><code>data:\n  sqlalchemy:\n    connections:\n      default:\n        url: \"${DATABASE_URL}\" # (1)\n\n      other: # (2)\n        url: \"${DATABASE_URL}\"\n        username: \"${DATABASE_USERNAME}\"\n        password: \"${DATABASE_PASSWORD}\"\n\n      another: # (3)\n        drivername: \"${DATABASE_DRIVERNAME}\"\n        host: \"${DATABASE_HOST}\"\n        port: ${DATABASE_PORT}\n        database: \"${DATABASE_NAME}\"\n        username: \"${DATABASE_USERNAME}\"\n        password: \"${DATABASE_PASSWORD}\"\n</code></pre> <ol> <li>Pode ser definido com a vari\u00e1vel de ambiente <code>SELVA__DATA__SQLALCHEMY__DEFAULT__URL</code></li> <li>Pode ser definido com as vari\u00e1veis de ambiente:<ul> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__OTHER__URL</code></li> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__OTHER__USERNAME</code></li> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__OTHER__PASSWORD</code></li> </ul> </li> <li>Pode ser definido com as vari\u00e1veis de ambiente:<ul> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__ANOTHER__DRIVERNAME</code></li> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__ANOTHER__HOST</code></li> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__ANOTHER__PORT</code></li> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__ANOTHER__DATABASE</code></li> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__ANOTHER__USERNAME</code></li> <li><code>SELVA__DATA__SQLALCHEMY__CONNECTIONS__ANOTHER__PASSWORD</code></li> </ul> </li> </ol>"},{"location":"pt/extensions/data/sqlalchemy/#trabalhando-com-async_sessionmaker","title":"Trabalhando com async_sessionmaker","text":"<p>Diferente do <code>AsyngEngine</code>, Selva cria apenas um \u00fanico <code>async_sessionmaker</code>. N\u00f3s podemos associar subclases espec\u00edficas de <code>DeclarativeBase</code> atrav\u00e9s da configura\u00e7\u00e3o <code>data.sqlalchemy.session.binds</code>, caso contr\u00e1rio ser\u00e1 associado \u00e0 conex\u00e3o <code>default</code>.</p> application/model.pyconfiguration/settings.yaml <pre><code>from sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass OtherBase(DeclarativeBase):\n    pass\n</code></pre> <pre><code>data:\n  sqlalchemy:\n    connections:\n      default:\n        url: \"sqlite+aiosqlite://db1.sqlite3\"\n      other:\n        url: \"sqlite+aiosqlite://db2.sqlite3\"\n    session:\n      binds:\n        application.model.Base: default\n        application.model.OtherBase: other\n</code></pre>"},{"location":"pt/extensions/data/sqlalchemy/#examplo","title":"Examplo","text":"application/handler.pyapplication/model.pyconfiguration/settings.yaml <pre><code>from sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import async_sessionmaker, AsyncEngine\n\nfrom asgikit.responses import respond_json\n\nfrom selva.di import Inject\nfrom selva.web import get\n\nfrom .model import Base, MyModel\n\n\n@get\nasync def index(\n    request,\n    engine: Annotated[AsyncEngine, Inject],\n    sessionmaker: Annotated[async_sessionmaker, Inject],\n):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    async with sessionmaker() as session:\n        my_model = MyModel(name=\"MyModel\")\n        session.add(my_model)\n        await session.commit()\n\n    async with sessionmaker() as session:\n        my_model = await session.scalar(select(MyModel).limit(1))\n        await respond_json(request.response, {\n            \"id\": my_model.id,\n            \"name\": my_model.name,\n        })\n</code></pre> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass MyModel(Base):\n    __tablename__ = 'my_model'\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String(length=100))\n\n    def __repr__(self):\n        return f\"&lt;MyModel(id={self.id}, name={self.name})&gt;\"\n</code></pre> <pre><code>data:\n  sqlalchemy:\n    default:\n      url: \"sqlite+aiosqlite://:memory:\"\n</code></pre>"},{"location":"pt/extensions/data/sqlalchemy/#opcoes-de-configuracao","title":"Op\u00e7\u00f5es de configura\u00e7\u00e3o","text":"<p>Selva oferece v\u00e1rias op\u00e7\u00f5es para configurar o SQLAlchemy. Se voc\u00ea precisar de mais controle sobre os servi\u00e7os do SQLAlchemy, voc\u00ea pode criar os seus pr\u00f3prios servi\u00e7os <code>AsyncEngine</code> e <code>async_sessionmaker</code>.</p> <p>As op\u00e7\u00f5es dispon\u00edveis s\u00e3o mostradas abaixo:</p> <pre><code>data:\n  sqlalchemy:\n    session:\n      options: # (1)\n        class: sqlalchemy.ext.asyncio.AsyncSession\n        autoflush: true\n        expire_on_commit: true\n        autobegin: true\n        twophase: false\n        enable_baked_queries: true\n        info: # (2)\n          field: \"value\"\n        # info: \"package.module.variable\"\n        query_cls: \"sqlalchemy.orm.query.Query\"\n        join_transaction_mode: \"conditional_savepoint\" # ou \"rollback_only\", \"control_fully\", \"create_savepoint\"\n        close_resets_only: null\n      binds: # (3)\n        application.model.Base: default\n        application.model.OtherBase: other\n    connections:\n      default:\n        url: \"\"\n        options: # (4)\n          connect_args: \"package.module.variable\" # (5)\n          echo: false\n          echo_pool: false\n          enable_from_linting: false\n          hide_parameters: false\n          insertmanyvalues_page_size: 1\n          isolation_level: \"\"\n          # caminho para a fun\u00e7\u00e3o de desserializa\u00e7\u00e3o json\n          json_deserializer: \"json.loads\"\n          # caminho para a fun\u00e7\u00e3o de serializa\u00e7\u00e3o json\n          json_serializer: \"json.dumps\"\n          label_length: 1\n          logging_name: \"\"\n          max_identifier_length: 1\n          max_overflow: 1\n          module: \"\"\n          paramstyle: \"qmark\" # ou \"numeric\", \"named\", \"format\", \"pyformat\"\n          # caminho para classe python\n          poolclass: \"sqlalchemy.pool.Pool\"\n          pool_logging_name: \"\"\n          pool_pre_ping: false\n          pool_size: 1\n          pool_recycle: 3600\n          pool_reset_on_return: \"rollback\" # ou \"commit\"\n          pool_timeout: 1\n          pool_use_lifo: false\n          plugins:\n            - \"plugin1\"\n            - \"plugin2\"\n          query_cache_size: 1\n          use_insertmanyvalues: false\n          execution_options: # (5)\n            logging_token: \"\"\n            isolation_level: \"\"\n            no_parameters: false\n            stream_results: false\n            max_row_buffer: 1\n            yield_per: 1\n            insertmanyvalues_page_size: 1\n            schema_translate_map:\n              null: \"my_schema\"\n              some_schema: \"other_schema\"\n</code></pre> <ol> <li>Valores s\u00e3o descritos em <code>sqlalchemy.orm.Session</code></li> <li>Pode ser um mapa ou um caminho para uma vari\u00e1vel python contendo um <code>dict</code></li> <li>Associa subclasses de <code>sqlalchemy.orm.DeclarativeBase</code> a nomes de conex\u00f5es definidas     em <code>connections</code></li> <li>Valores s\u00e3o descritos em <code>sqlalchemy.create_engine</code></li> <li><code>connect_args</code> \u00e9 um caminho para um <code>dict[str, Any]</code> que ser\u00e1 provido como argumentos     para a fun\u00e7\u00e3o <code>connect</code> do driver do banco de dados</li> <li>Valores de <code>execution_options</code> s\u00e3o descritos em <code>Sqlalchemy.engine.Connection.execution_options</code></li> </ol>"},{"location":"pt/extensions/templates/jinja/","title":"Jinja","text":"<p>Esta estens\u00e3o prov\u00ea suport para templates Jinja.</p>"},{"location":"pt/extensions/templates/jinja/#utilizacao","title":"Utiliza\u00e7\u00e3o","text":"<p>Para utilizar templates Jinja, primeiro instale o extra <code>jinja</code>:</p> <pre><code>pip install selva[jinja]\n</code></pre> <p>Depois ative a extens\u00e3o no arquivo de configura\u00e7\u00f5es:</p> <pre><code>extensions:\n  - selva.ext.templates.jinja\n</code></pre> <p>Para renderizar templates, injet o a depend\u00eancia <code>selva.ext.templates.jinja.JinjaTemplate</code> e chame o m\u00e9todo <code>respond</code>:</p> application.pyresources/templates/index.html <pre><code>from typing import Annotated\nfrom selva.di import Inject\nfrom selva.ext.templates.jinja import JinjaTemplate\nfrom selva.web import get\n\n@get\nasync def index(request, template: Annotated[JinjaTemplate, Inject]):\n    context = {\"title\": \"Index\"}\n    await template.respond(request.response, \"index.html\", context)\n</code></pre> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Jinja Templates&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;{{ title }}&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"pt/extensions/templates/jinja/#renderizar-templates-para-string","title":"Renderizar templates para string","text":"<p>A classe <code>JinjaTemplate</code> prov\u00ea m\u00e9todos para renderizar templates para <code>str</code>, ao inv\u00e9s de renderizar para a resposta.</p> <p>O m\u00e9todo <code>JinjaTempate.render</code> aceita um nome de template e retorna uma string com o template renderizado.</p> <p>O m\u00e9todo <code>JinjaTempate.render_str</code> aceita um template como string, o compila e retorna o resultado.</p> <pre><code>rendered = template.render(\"template.html\", {\"variable\": \"value\"})\nrendered = template.render_str(\"{{ variable }}\", {\"variable\": \"value\"})\n</code></pre>"},{"location":"pt/extensions/templates/jinja/#configuracao","title":"Configura\u00e7\u00e3o","text":"<p>Jinja pode ser configurado atrav\u00e9s do <code>settings.yaml</code>. Por exemplo, para ativar extens\u00f5es do Jinja:</p> <pre><code>templates:\n  jinja:\n    extensions:\n      - jinja2.ext.i18n\n      - jinja2.ext.debug\n</code></pre> <p>Lista completa de configura\u00e7\u00f5es:</p> <pre><code>templates:\n  jinja:\n    paths:\n      - resources/templates\n    block_start_string: \"\"\n    block_end_string: \"\"\n    variable_start_string: \"\"\n    variable_end_string: \"\"\n    comment_start_string: \"\"\n    comment_end_string: \"\"\n    line_statement_prefix: \"\"\n    line_comment_prefix: \"\"\n    trim_blocks: true\n    lstrip_blocks: true\n    newline_sequence: \"\\n\" # or \"\\r\\n\" or \"\\r\"\n    keep_trailing_newline: true\n    extensions:\n      - extension1\n      - extensions2\n    optimized: true\n    # caminho para uma classe python\n    undefined: \"package.module.Class\"\n    # caminho para uma fun\u00e7\u00e3o python\n    finalize: \"package.module.function\"\n    # caminho para uma fun\u00e7\u00e3o python\n    autoescape: \"package.module.function\"\n    # caminho para uma vari\u00e1vel python\n    loader: \"package.module:variable\"\n    cache_size: 1\n    auto_reload: true\n    # caminho para uma vari\u00e1vel python\n    bytecode_cache: \"package.module:variable\"\n</code></pre>"},{"location":"pt/extensions/templates/mako/","title":"Mako","text":"<p>Esta extens\u00e3o prov\u00ea suporte para templates Mako.</p>"},{"location":"pt/extensions/templates/mako/#utilizacao","title":"Utiliza\u00e7\u00e3o","text":"<p>Para utilizar templates Mako, primeiro instale o extra <code>mako</code>:</p> <pre><code>pip install selva[mako]\n</code></pre> <p>Depois ative a extens\u00e3o no arquivo de configura\u00e7\u00e3o:</p> <pre><code>extensions:\n  - selva.ext.templates.mako\n</code></pre> <p>Para renderizar templates, injete a depend\u00eancia <code>selva.ext.templates.mako.MakoTemplate</code> e chame o m\u00e9todo <code>respond</code>:</p> application.pyresources/templates/index.html <pre><code>from typing import Annotated\nfrom selva.di import Inject\nfrom selva.ext.templates.mako import MakoTemplate\nfrom selva.web import get\n\n@get\nasync def index(request, template: Annotated[MakoTemplate, Inject]):\n    context = {\"title\": \"Index\"}\n    await template.respond(request.response, \"index.html\", context)\n</code></pre> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Jinja Templates&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;${title}&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"pt/extensions/templates/mako/#renderizar-templates-para-string","title":"Renderizar templates para string","text":"<p>A classe <code>MakoTemplate</code> prov\u00ea m\u00e9todos para renderizar templates para <code>str</code>, ao inv\u00e9s de renderizar para a resposta.</p> <p>O m\u00e9todo <code>MakoTempate.render</code> aceita um nome de template e retorna uma string com o template renderizado.</p> <pre><code>rendered = template.render(\"template.html\", {\"variable\": \"value\"})\nrendered = template.render_str(\"${variable}\", {\"variable\": \"value\"})\n</code></pre>"},{"location":"pt/extensions/templates/mako/#configuracao","title":"Configura\u00e7\u00e3o","text":"<p>Mako pode ser configurado atrav\u00e9s do <code>settings.yaml</code>. Por exemplo, para ativar a op\u00e7\u00e3o \"filesystem_checks\":</p> <pre><code>templates:\n  mako:\n    directories:\n      - resources/mako\n    filesystem_checks: true\n</code></pre> <p>Lista completa de configura\u00e7\u00f5es:</p> <pre><code>templates:\n  mako:\n    directories:\n      - resources/templates\n    module_directory: \"\"\n    filesystem_checks: false\n    collection_size: 100\n    format_exceptions: false\n    # caminho para uma fun\u00e7\u00e3o python\n    error_handler: \"package.module.function\"\n    encoding_errors: \"strict\" # ou \"ignore\", \"replace\", \"xmlcharrefreplace\", \"htmlentityreplace\"\n    cache_enabled: true\n    cache_impl: \"beaker\"\n    # caminho para uma vari\u00e1vel python\n    cache_args: \"package.module:variable\"\n    # caminho para uma fun\u00e7\u00e3o python\n    modulename_callable: \"package.module.function\"\n    # caminho para uma fun\u00e7\u00e3o python\n    module_writer: \"package.module.function\"\n    default_filters: []\n    buffer_filters: []\n    strict_undefined: false\n    imports: []\n    future_imports: []\n    enable_loop: true\n    input_encoding: \"utf-8\"\n    # caminho para uma fun\u00e7\u00e3o python\n    preprocessor: \"package.module.function\"\n    # caminho para uma classe python\n    lexer_cls: \"package.module.Class\"\n    # caminho para uma fun\u00e7\u00e3o python\n    include_error_handler: \"package.module.function\"\n</code></pre>"},{"location":"pt/middleware/overview/","title":"Middleware","text":"<p>A linha de pipeline \u00e9 configurada com a propriedade de configura\u00e7\u00e3o <code>middleware</code>. Ela deve conter uma lista de fun\u00e7\u00f5es que recebem a pr\u00f3xima aplica\u00e7\u00e3o na linha, o objeto de configura\u00e7\u00f5es e o cont\u00eainer de inje\u00e7\u00e3o de depend\u00eancias e deve retornar uma inst\u00e2ncia de middleware asgi.</p> <pre><code>def middleware_factory(app, settings, di):\n    async def inner(scope, receive, send):\n        await app(scope, receive, send)\n\n    return inner\n</code></pre> <p>Qualquer middleware asgi pode ser usado na linha de middleware. Por exemplo, \u00e9 poss\u00edvel utilizar o SessionMiddleware do starlette:</p> application/middleware.pyconfiguration/settings.yaml <pre><code>from starlette.middleware.sessions import SessionMiddleware\n\n\ndef session_middleware(app, settings, di):\n    return SessionMiddleware(app, secret_key=settings.session.secret_key)\n</code></pre> <pre><code>middleware:\n  - application.middleware:session_middleware\n\nsession:\n  secret_key: super_secret_key\n</code></pre>"},{"location":"pt/middleware/overview/#utilizacao","title":"Utiliza\u00e7\u00e3o","text":"<p>Para demonstrar o systema de middleware, n\u00f3s criaremos um middleware temporizador que exibir\u00e1 no console o tempo gasto no processamento da requisi\u00e7\u00e3o::</p> application/handler.pyapplication/middleware.pyconfiguration/settings.yaml <pre><code>from asgikit.requests import Request\nfrom asgikit.responses import respond_json\nfrom selva.web import get\n\n\n@get\nasync def hello(request: Request):\n    await respond_json(request.response, {\"greeting\": \"Hello, World!\"})\n</code></pre> <pre><code>from collections.abc import Callable\nfrom datetime import datetime\n\nimport structlog\n\nfrom selva.di import service\n\nlogger = structlog.get_logger()\n\n\ndef timing_middleware(app, settings, di):\n    async def inner(scope, receive, send):\n        request_start = datetime.now()\n        await app(scope, receive, send)\n        request_end = datetime.now()\n\n        delta = request_end - request_start\n        logger.info(\"request duration\", duration=str(delta))\n    return inner\n</code></pre> <pre><code>middleware:\n  - application.middleware.timing_middleware\n</code></pre>"},{"location":"pt/middleware/overview/#dependencias-do-middleware","title":"Depend\u00eancias do middleware","text":"<p>Fun\u00e7\u00f5es de middleware pode usar o cont\u00eainer de inje\u00e7\u00e3o de depend\u00eancias para recuperar servi\u00e7os que o middleware possa precisar. N\u00f3s podemos reescrever o middleware temporizador para persistir os tempos usando um servi\u00e7o ao inv\u00e9s de exibir no console:</p> application/middleware.pyapplication/service.py <pre><code>from datetime import datetime\n\nfrom application.service import TimingService\n\n\nclass TimingMiddleware:\n    def __init__(self, app, timing_service: TimingService):\n        self.timing_service = timing_service\n\n    async def __call__(self, scope, receive, send):\n        request_start = datetime.now()\n        await app(scope, receive, send)\n        request_end = datetime.now()\n\n        await self.timing_service.save(request_start, request_end)\n\n\nasync def timing_middleware(app, settings, di):\n    timing_service = await di.get(TimingService)\n    return TimingMiddleware(app, timing_service)\n</code></pre> <pre><code>from datetime import datetime\n\nfrom selva.di import service\n\n@service\nclass TimingService:\n    async def save(start: datetime, end: datetime):\n        ...\n</code></pre>"},{"location":"pt/middleware/staticfiles_uploads/","title":"Arquivos est\u00e1ticos e uploads","text":"<p>Os middlewares <code>static_files_middleware</code> e <code>uploaded_files_middleware</code> prov\u00eaem uma forma de servir conte\u00fado est\u00e1tico e uploads de usu\u00e1rios.</p> <p>H\u00e1 dois middlewares separados que permitem tratamentos distintos na linha de middleware. Por exemplo, voc\u00ea poderia definir que os uploads deve ser servidos ap\u00f3s autoriza\u00e7\u00e3o, enquanto os arquivos est\u00e1ticos permanecer com acesso p\u00fablico.</p>"},{"location":"pt/middleware/staticfiles_uploads/#utilizacao","title":"Utiliza\u00e7\u00e3o","text":"<p>Primeiro voc\u00ea deve ativar os middlewares no <code>settings.yaml</code>.</p> <pre><code>middleware:\n  # ...\n  - selva.web.middleware.files.static_files_middleware\n  - selva.web.middleware.files.uploaded_files_middleware\n  # ...\n</code></pre> <p>Ap\u00f3s isto, arquivos localizados nos diret\u00f3rios <code>resources/static</code> e <code>resources/uploads</code> ser\u00e3o servidos em <code>/static/</code> e <code>/uploads/</code>, respectivamente.</p>"},{"location":"pt/middleware/staticfiles_uploads/#mapeamentos-de-arquivos-estaticos","title":"Mapeamentos de arquivos est\u00e1ticos","text":"<p>Voc\u00ea pode mapear caminhos espec\u00edficos para um arquivo est\u00e1tico em particular para, por exemplo, servir o favicon em <code>/favicon.ico</code> apontando para um arquivo em <code>resources/static/</code>:</p> <pre><code>middleware:\n  - selva.web.middleware.files.static_files_middleware\nstaticfiles:\n  mappings:\n    favicon.ico: my-icon.ico\n</code></pre>"},{"location":"pt/middleware/staticfiles_uploads/#configuracoes","title":"Configura\u00e7\u00f5es","text":"<p>As op\u00e7\u00f5es dispon\u00edveis para configurar <code>static_files_middleware</code> e <code>uploaded_files_middleware</code> s\u00e3o mostradas abaixo:</p> <pre><code>staticfiles:\n    path: /static # (1)\n    root: resources/static # (2)\n    mappings: {}\n\nuploadedfiles:\n    path: /uploads # (3)\n    root: resources/uploads # (4)\n</code></pre> <ol> <li>Caminho onde os arquivos est\u00e1ticos s\u00e3o servidos</li> <li>Diret\u00f3rio onde os arquivos est\u00e1ticos s\u00e3o localizados</li> <li>Caminho onde os uploads s\u00e3o servidos</li> <li>Diret\u00f3rio onde os uploads s\u00e3o localizados</li> </ol>"}]}